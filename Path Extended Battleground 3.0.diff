

+++ src\map\battleground.cpp
@ -5,19 +5,24 @@

#include <unordered_map>

-#include <common/cbasetypes.hpp>
-#include <common/malloc.hpp>
-#include <common/nullpo.hpp>
-#include <common/random.hpp>
-#include <common/showmsg.hpp>
-#include <common/strlib.hpp>
-#include <common/timer.hpp>
-#include <common/utilities.hpp>
-
+#include "../common/cbasetypes.hpp"
+#include "../common/malloc.hpp"
+#include "../common/nullpo.hpp"
+#include "../common/random.hpp"
+#include "../common/showmsg.hpp"
+#include "../common/strlib.hpp"
+#include "../common/socket.hpp"
+#include "../common/timer.hpp"
+#include "../common/utilities.hpp"
+#include "../common/utils.hpp"
+
+#include "achievement.hpp"
#include "battle.hpp"
#include "clif.hpp"
+#include "elemental.hpp"
#include "guild.hpp"
#include "homunculus.hpp"
+#include "log.hpp"
#include "mapreg.hpp"
#include "mercenary.hpp"
#include "mob.hpp"
@ -25,6 +30,8 @@
#include "party.hpp"
#include "pc.hpp"
#include "pet.hpp"
+#include "quest.hpp"
+#include "skill.hpp"

using namespace rathena;

@ -33,6 +40,13 @@ std::unordered_map<int, std::shared_ptr<s_battleground_data>> bg_team_db;
std::vector<std::shared_ptr<s_battleground_queue>> bg_queues;
int bg_queue_count = 1;

+#define BLUE_SKULL 8965
+#define RED_SKULL 8966
+#define GREEN_SKULL 8967
+
+struct guild bg_guild[13]; // Temporal fake guild information
+const unsigned int bg_colors[13] = { 0x0000FF, 0xFF0000, 0x00FF00, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF };
+
const std::string BattlegroundDatabase::getDefaultLocation() {
	return std::string(db_path) + "/battleground_db.yml";
}
@ -402,6 +416,423 @@ uint64 BattlegroundDatabase::parseBodyNode(const ryml::NodeRef& node) {
	return 1;
}

+
+void bg_guild_build_data(void)
+{
+	int i, j, k, skill;
+	memset(&bg_guild, 0, sizeof(bg_guild));
+	for( i = 1; i <= 13; i++ )
+	{ // Emblem Data - Guild ID's
+		FILE* fp = NULL;
+		char path[256];
+
+		j = i - 1;
+		bg_guild[j].emblem_id = 1; // Emblem Index
+		bg_guild[j].guild_id = INT_MAX - j;
+		bg_guild[j].guild_lv = 1;
+		bg_guild[j].max_member = MAX_BG_MEMBERS;
+		bg_guild[j].skill_point = 0;
+		bg_guild[j].average_lv = 99;
+
+		// Skills
+		if( j < 3 )
+		{ // Clan Skills
+			for( k = 0; k < MAX_GUILDSKILL-1; k++ )
+			{
+				skill = k + GD_SKILLBASE;
+				bg_guild[j].skill[k].id = skill;
+				switch( skill )
+				{
+				case GD_GLORYGUILD:
+					bg_guild[j].skill[k].lv = 0;
+					break;
+				case GD_APPROVAL:
+				case GD_KAFRACONTRACT:
+				case GD_GUARDRESEARCH:
+				case GD_BATTLEORDER:
+				case GD_RESTORE:
+				case GD_EMERGENCYCALL:
+				case GD_DEVELOPMENT:
+					bg_guild[j].skill[k].lv = 1;
+					break;
+				case GD_GUARDUP:
+				case GD_REGENERATION:
+					bg_guild[j].skill[k].lv = 3;
+					break;
+				case GD_LEADERSHIP:
+				case GD_GLORYWOUNDS:
+				case GD_SOULCOLD:
+				case GD_HAWKEYES:
+					bg_guild[j].skill[k].lv = 5;
+					break;
+				case GD_EXTENSION:
+					bg_guild[j].skill[k].lv = 10;
+					break;
+				}
+			}
+		}
+		else
+		{ // Other Data
+			snprintf(bg_guild[j].name, NAME_LENGTH, "Team %d", i - 3); // Team 1, Team 2 ... Team 10
+			strncpy(bg_guild[j].master, bg_guild[j].name, NAME_LENGTH);
+			snprintf(bg_guild[j].position[0].name, NAME_LENGTH, "%s Leader", bg_guild[j].name);
+			strncpy(bg_guild[j].position[1].name, bg_guild[j].name, NAME_LENGTH);
+		}
+
+		sprintf(path, "%s/emblems/bg_%d.ebm", db_path, i);
+		if( (fp = fopen(path, "rb")) != NULL )
+		{
+			fseek(fp, 0, SEEK_END);
+			bg_guild[j].emblem_len = ftell(fp);
+			fseek(fp, 0, SEEK_SET);
+			if (fread(&bg_guild[j].emblem_data, 1, bg_guild[j].emblem_len, fp) == bg_guild[j].emblem_len) {
+				fclose(fp);
+				ShowStatus("Done reading '%s' emblem data file.\n", path);
+			} else
+				ShowStatus("Failed to read '%s'.\n", path); // Never happen
+		}
+	}
+
+	// Guild Data - Guillaume
+	strncpy(bg_guild[0].name, "Blue Team", NAME_LENGTH);
+	strncpy(bg_guild[0].master, "General Guillaume", NAME_LENGTH);
+	strncpy(bg_guild[0].position[0].name, "Blue Team Leader", NAME_LENGTH);
+	strncpy(bg_guild[0].position[1].name, "Blue Team", NAME_LENGTH);
+
+	// Guild Data - Croix
+	strncpy(bg_guild[1].name, "Red Team", NAME_LENGTH);
+	strncpy(bg_guild[1].master, "Prince Croix", NAME_LENGTH);
+	strncpy(bg_guild[1].position[0].name, "Red Team Leader", NAME_LENGTH);
+	strncpy(bg_guild[1].position[1].name, "Red Team", NAME_LENGTH);
+
+	// Guild Data - Traitors
+	strncpy(bg_guild[2].name, "Green Team", NAME_LENGTH);
+	strncpy(bg_guild[2].master, "Mercenary", NAME_LENGTH);
+	strncpy(bg_guild[2].position[0].name, "Green Team Leader", NAME_LENGTH);
+	strncpy(bg_guild[2].position[1].name, "Green Team", NAME_LENGTH);
+}
+
+int bg_checkskill(struct s_battleground_data *bg, int id)
+{
+	int idx = id - GD_SKILLBASE;
+	if( idx < 0 || idx >= MAX_GUILDSKILL-1 || !bg->g )
+		return 0;
+	return bg->g->skill[idx].lv;
+}
+
+TIMER_FUNC(bg_block_skill_end)
+{
+	std::shared_ptr<s_battleground_data> bg;
+	char output[128];
+	int idx = (int)data - GD_SKILLBASE;
+
+	if( (bg = util::umap_find(bg_team_db, id)) == NULL )
+		return 1;
+
+	if( idx < 0 || idx >= MAX_GUILDSKILL-1 )
+	{
+		ShowError("bg_block_skill_end invalid skill_id %d.\n", (int)data);
+		return 0;
+	}
+
+	if( tid != bg->skill_block_timer[idx] )
+	{
+		ShowError("bg_block_skill_end %d != %d.\n", bg->skill_block_timer[idx], tid);
+		return 0;
+	}
+
+	sprintf(output, "%s : Guild Skill %s Ready!!", bg->g->name, skill_get_desc((int)data));
+	clif_bg_message(bg.get(), 0, bg->g->name, output, strlen(output) + 1);
+	bg->skill_block_timer[idx] = INVALID_TIMER;
+
+	return 1;
+}
+
+void bg_block_skill_start(struct s_battleground_data *bg, int skill_id, t_tick time)
+{
+	int idx = skill_id - GD_SKILLBASE;
+	if( bg == NULL || idx < 0 || idx >= MAX_GUILDSKILL-1 )
+		return;
+
+	if (bg->skill_block_timer[idx] != INVALID_TIMER)
+		delete_timer(bg->skill_block_timer[idx], bg_block_skill_end);
+
+	bg->skill_block_timer[idx] = add_timer(gettick() + time, bg_block_skill_end, bg->id, skill_id);
+}
+
+bool bg_block_skill_status(struct s_battleground_data *bg, int skill_id)
+{
+	const struct TimerData * td;
+	char output[128];
+	int idx;
+	t_tick seconds;
+
+	idx = skill_id - GD_SKILLBASE;
+	if (bg == NULL || bg->g == NULL || idx < 0 || idx >= MAX_GUILDSKILL-1 || bg->skill_block_timer[idx] == INVALID_TIMER)
+		return false;
+
+	if ((td = get_timer(bg->skill_block_timer[idx])) == NULL)
+		return false;
+
+	seconds = DIFF_TICK(td->tick,gettick())/1000;
+	sprintf(output, "%s : Cannot use team skill [%s]. %I64i seconds remaining................", bg->g->name, skill_get_desc(skill_id), seconds);
+	clif_bg_message(bg, 0, bg->g->name, output, strlen(output) + 1);
+
+	return true;
+}
+
+void guild_block_skill_status(map_session_data *sd, int skillid)
+{
+	if (!sd)
+		return;
+	struct guild *g;
+	const struct TimerData * td;
+	char output[128];
+	int i;
+	t_tick seconds;
+
+	if((g = sd->guild) == NULL )
+		return;
+	if (!SKILL_CHK_GUILD(skillid))
+		return;
+	if ((i = skill_blockpc_get(sd,skillid)) == -1)
+		return;
+	if( (td = get_timer(sd->scd[i]->timer)) == NULL )
+		return;
+
+	seconds = DIFF_TICK(td->tick,gettick())/1000;
+	sprintf(output, "Guild: Cannot use skill [%s]. %I64i seconds remaining................", skill_get_desc(skillid), seconds);
+	clif_guild_message(g ,0 ,output , strlen(output) + 1);
+}
+
+int guild_skills_timer(map_session_data *sd, int skillid)
+{
+	if (!sd)
+		return -2;
+	struct guild *g;
+	std::shared_ptr<s_battleground_data> bg;
+	const struct TimerData * td;
+	int i;
+
+	if (!SKILL_CHK_GUILD(skillid))
+		return -2;
+	if (sd->bg_id) {
+		skillid -= GD_SKILLBASE;
+		if (!(bg = util::umap_find(bg_team_db, sd->bg_id)))
+			return -2;
+		if (bg->skill_block_timer[skillid] == INVALID_TIMER)
+			return -1;
+		if ((td = get_timer(bg->skill_block_timer[skillid])) == NULL )
+			return -1;
+	} else if ((g = sd->guild)) {
+		if ((i = skill_blockpc_get(sd,skillid)) == -1)
+			return -1;
+		if( (td = get_timer(sd->scd[i]->timer)) == NULL )
+			return -1;
+	} else
+		return -2;
+
+	return (int)DIFF_TICK(td->tick,gettick())/1000;
+}
+
+int bg_reveal_pos(struct block_list *bl, va_list ap)
+{
+	struct map_session_data *pl_sd, *sd = NULL;
+	int flag, color;
+
+	pl_sd = (struct map_session_data *)bl;
+	sd = va_arg(ap,struct map_session_data *); // Source
+	flag = va_arg(ap,int);
+	color = va_arg(ap,int);
+
+	if( pl_sd->bg_id == sd->bg_id )
+		return 0; // Same Team
+
+	clif_viewpoint(pl_sd,sd->bl.id,flag,sd->bl.x,sd->bl.y,sd->bl.id,color);
+	return 0;
+}
+
+void bg_team_getitem(int bg_id, int nameid, int amount, int reward)
+{
+	std::shared_ptr<s_battleground_data> bg;
+	struct item it;
+	int flag, amount2 = 0;
+
+	if (amount < 1 || !(bg = util::umap_find(bg_team_db, bg_id)) || !(item_db.exists(nameid)))
+		return;
+
+	if (reward)
+		amount2 = amount;
+
+	if(reward && battle_config.bg_reward_rates != 100 )
+		amount = amount * battle_config.bg_reward_rates / 100;
+
+	memset(&it, 0, sizeof(it));
+	it.nameid = nameid;
+	it.identify = 1;
+
+	for (const auto &member : bg->members) {
+		if (pc_isvip(member.sd)) {
+			if(reward && battle_config.bg_reward_rates_vip)
+				amount += amount2 * battle_config.bg_reward_rates_vip / 100;
+		}
+		if ((flag = pc_additem(member.sd, &it, amount, LOG_TYPE_SCRIPT)))
+			clif_additem(member.sd, 0, 0, flag);
+	}
+}
+
+int bg_member_removeskulls(map_session_data *sd)
+{
+	int n;
+	nullpo_ret(sd);
+	if( (n = pc_search_inventory(sd,BLUE_SKULL)) >= 0 )
+		pc_delitem(sd,n,sd->inventory.u.items_inventory[n].amount,0,2,LOG_TYPE_OTHER);
+	if( (n = pc_search_inventory(sd,RED_SKULL)) >= 0 )
+		pc_delitem(sd,n,sd->inventory.u.items_inventory[n].amount,0,2,LOG_TYPE_OTHER);
+	if( (n = pc_search_inventory(sd,GREEN_SKULL)) >= 0 )
+		pc_delitem(sd,n,sd->inventory.u.items_inventory[n].amount,0,2,LOG_TYPE_OTHER);
+
+	return 1;
+}
+
+/* ==============================================================
+bg_arena (0 EoS | 1 Boss | 2 TI | 3 CTF | 4 TD | 5 SC | 6 CON)
+bg_result (0 Won | 1 Tie | 2 Lost)
++============================================================== */
+void bg_team_rewards(int bg_id, int nameid, int amount, int kafrapoints, int quest_id, const char *var, int add_value, int bg_arena, int bg_result, int fame)
+{
+	std::shared_ptr<s_battleground_data> bg;
+	struct item it;
+	int flag, amount_vip, kafrapoints_vip = 0;
+
+	if (amount < 1 || !(bg = util::umap_find(bg_team_db, bg_id)) || !(item_db.exists(nameid)))
+		return;
+
+	if (battle_config.bg_reward_rates != 100) { // BG Reward Rates
+		amount = amount * battle_config.bg_reward_rates / 100;
+		kafrapoints = kafrapoints * battle_config.bg_reward_rates / 100;
+	}
+
+	if (battle_config.bg_reward_rates_vip) {
+		amount_vip = amount + (amount * battle_config.bg_reward_rates_vip / 100);
+		kafrapoints_vip = kafrapoints + (kafrapoints * battle_config.bg_reward_rates_vip / 100);
+	}
+
+	bg_result = cap_value(bg_result, 0, 2);
+	memset(&it, 0, sizeof(it));
+	it.nameid = nameid;
+	it.identify = 1;
+
+	for (const auto &member : bg->members) {
+		if (pc_isvip(member.sd)) {
+			if (kafrapoints_vip)
+				pc_getcash(member.sd, 0, kafrapoints_vip, LOG_TYPE_SCRIPT);
+			if ((flag = pc_additem(member.sd, &it, amount_vip, LOG_TYPE_SCRIPT)))
+				clif_additem(member.sd, 0, 0, flag);
+		} else {
+			if (kafrapoints)
+				pc_getcash(member.sd, 0, kafrapoints, LOG_TYPE_SCRIPT);
+			if ((flag = pc_additem(member.sd, &it, amount, LOG_TYPE_SCRIPT)))
+				clif_additem(member.sd, 0, 0, flag);
+		}
+		if (add_value)
+			pc_setglobalreg(member.sd, add_str(var), pc_readglobalreg(member.sd, add_str(var)) + add_value);
+		if (fame)
+			pc_addbgpoints(member.sd,fame);
+
+		achievement_update_objective(member.sd, AG_BG_DAMAGE, 1, member.sd->status.bgstats.damage_done);
+		switch(bg_result) {
+			case 0: // Won
+				add2limit(member.sd->status.bgstats.win,1,USHRT_MAX);
+				achievement_update_objective(member.sd, AG_BG_WIN, 1, 1);
+				if (member.sd->state.bmaster_flag)
+					add2limit(member.sd->status.bgstats.leader_win,1,USHRT_MAX);
+				switch(bg_arena) {
+					case 0: add2limit(member.sd->status.bgstats.eos_wins,1,USHRT_MAX); break;
+					case 1: add2limit(member.sd->status.bgstats.boss_wins,1,USHRT_MAX); break;
+					case 2: add2limit(member.sd->status.bgstats.ti_wins,1,USHRT_MAX); break;
+					case 3: add2limit(member.sd->status.bgstats.ctf_wins,1,USHRT_MAX); break;
+					case 4: add2limit(member.sd->status.bgstats.td_wins,1,USHRT_MAX); break;
+					case 5: add2limit(member.sd->status.bgstats.sc_wins,1,USHRT_MAX); break;
+					case 6: add2limit(member.sd->status.bgstats.cq_wins,1,USHRT_MAX); break;
+					case 7: add2limit(member.sd->status.bgstats.ru_wins,1,USHRT_MAX); break;
+					case 8: add2limit(member.sd->status.bgstats.dom_wins,1,USHRT_MAX); break;
+				}
+				break;
+			case 1: // Tie
+				add2limit(member.sd->status.bgstats.tie,1,USHRT_MAX);
+				achievement_update_objective(member.sd, AG_BG_TIE, 1, 1);
+				if (member.sd->state.bmaster_flag)
+					add2limit(member.sd->status.bgstats.leader_tie,1,USHRT_MAX);
+				switch( bg_arena ) {
+					case 0: add2limit(member.sd->status.bgstats.eos_tie,1,USHRT_MAX); break;
+					case 1: add2limit(member.sd->status.bgstats.boss_tie,1,USHRT_MAX); break;
+					case 2: add2limit(member.sd->status.bgstats.ti_tie,1,USHRT_MAX); break;
+					case 3: add2limit(member.sd->status.bgstats.ctf_tie,1,USHRT_MAX); break;
+					case 4: add2limit(member.sd->status.bgstats.td_tie,1,USHRT_MAX); break;
+					case 5: add2limit(member.sd->status.bgstats.sc_tie,1,USHRT_MAX); break;
+					// No Tie for Conquest or Rush
+					case 8: add2limit(member.sd->status.bgstats.dom_tie,1,USHRT_MAX); break;
+				}
+				break;
+			case 2: // Lost
+				add2limit(member.sd->status.bgstats.lost,1,USHRT_MAX);
+				achievement_update_objective(member.sd, AG_BG_LOSE, 1, 1);
+				if (member.sd->state.bmaster_flag)
+					add2limit(member.sd->status.bgstats.leader_lost,1,USHRT_MAX);
+				switch(bg_arena) {
+					case 0: add2limit(member.sd->status.bgstats.eos_lost,1,USHRT_MAX); break;
+					case 1: add2limit(member.sd->status.bgstats.boss_lost,1,USHRT_MAX); break;
+					case 2: add2limit(member.sd->status.bgstats.ti_lost,1,USHRT_MAX); break;
+					case 3: add2limit(member.sd->status.bgstats.ctf_lost,1,USHRT_MAX); break;
+					case 4: add2limit(member.sd->status.bgstats.td_lost,1,USHRT_MAX); break;
+					case 5: add2limit(member.sd->status.bgstats.sc_lost,1,USHRT_MAX); break;
+					case 6: add2limit(member.sd->status.bgstats.cq_lost,1,USHRT_MAX); break;
+					case 7: add2limit(member.sd->status.bgstats.ru_lost,1,USHRT_MAX); break;
+					case 8: add2limit(member.sd->status.bgstats.dom_lost,1,USHRT_MAX); break;
+				}
+				break;
+		}
+	}
+}
+
+/**
+ * Get how many clients are active
+ * @return login counts
+ */
+int bg_countlogin(map_session_data *sd)
+{
+	int c = 0;
+	struct map_session_data* pl_sd;
+	struct s_mapiterator* iter;
+	nullpo_ret(sd);
+
+	iter = mapit_getallusers();
+	for (pl_sd = (TBL_PC*)mapit_first(iter); mapit_exists(iter); pl_sd = (TBL_PC*)mapit_next(iter))
+	{
+		//if (session[sd->fd]->gepard_info.unique_id != session[pl_sd->fd]->gepard_info.unique_id)
+		if( session[sd->fd]->client_addr == session[pl_sd->fd]->client_addr )
+			continue;
+		if (pl_sd->bg_queue_id || bg_player_is_in_bg_map(pl_sd))
+		c++;
+	}
+	mapit_free(iter);
+	return c;
+}
+
+/**
+ * Get Team Guild structure
+ * @param bg_id: Battleground Id
+ * @return guild struct
+ */
+struct guild* bg_guild_get(int bg_id)
+{ // Return Fake Guild for BG Members
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_id);
+	if( bg == NULL ) return NULL;
+	return bg->g;
+}
+
+
/**
 * Search for a battleground based on the given name
 * @param name: Battleground name
@ -434,6 +865,21 @@ std::shared_ptr<s_battleground_queue> bg_search_queue(int queue_id)
	return nullptr;
}

+/**
+ * Search for a Battleground queue based on the given ID
+ * @param id: ID
+ * @return s_battleground_queue on success or nullptr on failure
+ */
+std::shared_ptr<s_battleground_queue> bg_search_queue_id(int id)
+{
+	for (const auto &queue : bg_queues) {
+		if (id == queue->id)
+			return queue;
+	}
+
+	return nullptr;
+}
+
/**
 * Search for an available player in Battleground
 * @param bg: Battleground data
@ -459,12 +905,19 @@ map_session_data* bg_getavailablesd(s_battleground_data *bg)
bool bg_team_delete(int bg_id)
{
	std::shared_ptr<s_battleground_data> bgteam = util::umap_find(bg_team_db, bg_id);
+	int i;

	if (bgteam) {
		for (const auto &pl_sd : bgteam->members) {
			bg_send_dot_remove(pl_sd.sd);
			pl_sd.sd->bg_id = 0;
		}
+		for(i = 0; i < MAX_GUILDSKILL-1; i++)
+		{
+			if (bgteam->skill_block_timer[i] == INVALID_TIMER)
+				continue;
+			delete_timer(bgteam->skill_block_timer[i], bg_block_skill_end);
+		}

		bg_team_db.erase(bg_id);

@ -504,8 +957,12 @@ void bg_send_dot_remove(map_session_data *sd)
{
	nullpo_retv(sd);

-	if( sd && sd->bg_id )
+	if (sd && sd->bg_id) {
+		std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, sd->bg_id);
		clif_bg_xy_remove(sd);
+		if (bg && bg->reveal_pos && bg_player_is_in_bg_map(sd))
+			map_foreachinmap(bg_reveal_pos, sd->bl.m, BL_PC, sd, 2, 0xFFFFFF);
+	}
	return;
}

@ -530,6 +987,40 @@ bool bg_team_join(int bg_id, map_session_data *sd, bool is_queue)
		s_battleground_member_data member = {};

		sd->bg_id = bg_id;
+
+		//Extended Battleground [Easycore]
+		sd->bg_queue_id = 0;
+		pc_update_last_action(sd);
+		sd->state.bg_afk = 0;
+
+		if (battle_config.bg_remove_buffs) {
+			if (battle_config.bg_remove_buffs&1) {
+				status_change_end(&sd->bl, SC_INCREASEAGI, INVALID_TIMER);
+				status_change_end(&sd->bl, SC_BLESSING, INVALID_TIMER);
+			}
+			if (battle_config.bg_remove_buffs&2)
+				status_change_end(&sd->bl, SC_SPIRIT, INVALID_TIMER);
+			if (battle_config.bg_remove_buffs&4) {
+				status_change_end(&sd->bl, SC_CP_WEAPON, INVALID_TIMER);
+				status_change_end(&sd->bl, SC_CP_SHIELD, INVALID_TIMER);
+				status_change_end(&sd->bl, SC_CP_ARMOR, INVALID_TIMER);
+				status_change_end(&sd->bl, SC_CP_HELM, INVALID_TIMER);
+			}
+			if (battle_config.bg_remove_buffs&8)
+				status_change_end(&sd->bl, SC_GOSPEL, INVALID_TIMER);
+			if (battle_config.bg_remove_buffs&16) {
+				status_change_end(&sd->bl, SC_KYRIE, INVALID_TIMER);
+				status_change_end(&sd->bl, SC_ASSUMPTIO, INVALID_TIMER);
+			}
+			if (battle_config.bg_remove_buffs&32)
+				status_change_end(&sd->bl, SC_EDP, INVALID_TIMER);
+			if (battle_config.bg_remove_buffs&64) {
+				status_change_end(&sd->bl, SC_KAITE, INVALID_TIMER);
+				status_change_end(&sd->bl, SC_KAUPE, INVALID_TIMER);
+				status_change_end(&sd->bl, SC_KAIZEL, INVALID_TIMER);
+			}
+		}
+
		member.sd = sd;
		member.x = sd->bl.x;
		member.y = sd->bl.y;
@ -539,14 +1030,31 @@ bool bg_team_join(int bg_id, map_session_data *sd, bool is_queue)
			member.entry_point.y = sd->bl.y;
		}
		bgteam->members.push_back(member);
+		
+		if (bgteam->leader_char_id == 0) { // First Join = Team Leader
+			bgteam->leader_char_id = sd->status.char_id;
+			sd->state.bmaster_flag = 1;
+		}

		guild_send_dot_remove(sd);

+		//Extended Battleground [Easycore]
+		clif_bg_belonginfo(sd);
+		clif_guild_masterormember(sd);
+		clif_name_area(&sd->bl);
+		skill_blockpc_clear(sd);
+
		for (const auto &pl_sd : bgteam->members) {
-			if (pl_sd.sd != sd)
+			if (pl_sd.sd != sd) {
+				// Simulate Guild Information [Easycore]
+				clif_guild_basicinfo(*pl_sd.sd);
+				clif_bg_emblem(pl_sd.sd, bgteam->g);
+				clif_bg_memberlist(pl_sd.sd);
				clif_hpmeter_single( *sd, pl_sd.sd->bl.id, pl_sd.sd->battle_status.hp, pl_sd.sd->battle_status.max_hp );
+			}
		}

+		clif_guild_emblem_area(&sd->bl);
		clif_bg_hp(sd);
		clif_bg_xy(sd);
		return true;
@ -568,12 +1076,69 @@ int bg_team_leave(map_session_data *sd, bool quit, bool deserter)
		return -1;

	bg_send_dot_remove(sd);
+	bg_member_removeskulls(sd);

	int bg_id = sd->bg_id;
	std::shared_ptr<s_battleground_data> bgteam = util::umap_find(bg_team_db, bg_id);
+	struct guild *g;

	sd->bg_id = 0;

+	//Extended Battleground [Easycore]
+	sd->state.bg_afk = 0;
+	sd->state.bmaster_flag = 0;
+	
+	// Remove Guild Skill Buffs
+	status_change_end(&sd->bl, SC_GUILDAURA, INVALID_TIMER);
+	status_change_end(&sd->bl, SC_BATTLEORDERS, INVALID_TIMER);
+	status_change_end(&sd->bl, SC_REGENERATION, INVALID_TIMER);
+	
+	if (battle_config.bg_remove_buffs) {
+		if (battle_config.bg_remove_buffs&1) {
+			status_change_end(&sd->bl, SC_INCREASEAGI, INVALID_TIMER);
+			status_change_end(&sd->bl, SC_BLESSING, INVALID_TIMER);
+		}
+		if (battle_config.bg_remove_buffs&2)
+			status_change_end(&sd->bl, SC_SPIRIT, INVALID_TIMER);
+		if (battle_config.bg_remove_buffs&4) {
+			status_change_end(&sd->bl, SC_CP_WEAPON, INVALID_TIMER);
+			status_change_end(&sd->bl, SC_CP_SHIELD, INVALID_TIMER);
+			status_change_end(&sd->bl, SC_CP_ARMOR, INVALID_TIMER);
+			status_change_end(&sd->bl, SC_CP_HELM, INVALID_TIMER);
+		}
+		if (battle_config.bg_remove_buffs&8)
+			status_change_end(&sd->bl, SC_GOSPEL, INVALID_TIMER);
+		if (battle_config.bg_remove_buffs&16) {
+			status_change_end(&sd->bl, SC_KYRIE, INVALID_TIMER);
+			status_change_end(&sd->bl, SC_ASSUMPTIO, INVALID_TIMER);
+		}
+		if (battle_config.bg_remove_buffs&32)
+			status_change_end(&sd->bl, SC_EDP, INVALID_TIMER);
+		if (battle_config.bg_remove_buffs&64) {
+			status_change_end(&sd->bl, SC_KAITE, INVALID_TIMER);
+			status_change_end(&sd->bl, SC_KAUPE, INVALID_TIMER);
+			status_change_end(&sd->bl, SC_KAIZEL, INVALID_TIMER);
+		}
+	}
+	if (battle_config.bg_buffs_on_leave && !deserter) {
+		sc_start(&sd->bl,&sd->bl,SC_INCAGI,100,10,240000);
+		sc_start(&sd->bl,&sd->bl,SC_BLESSING,100,10,240000);
+	}
+
+	// Refresh Guild Information
+	if (sd->status.guild_id && (g = guild_search(sd->status.guild_id)) != NULL)	{
+		clif_guild_belonginfo(*sd);
+		clif_guild_basicinfo(*sd);
+		clif_guild_allianceinfo(sd);
+		clif_guild_memberlist(*sd);
+		clif_guild_skillinfo(sd);
+		clif_guild_emblem(sd, g);
+	} else
+		clif_bg_leave_single(sd, sd->status.name, "Leaving Battleground...");
+
+	clif_name_area(&sd->bl);
+	clif_guild_emblem_area(&sd->bl);
+
	if (bgteam) {
		// Warping members out only applies to the Battleground Queue System
		if (battle_config.feature_bgqueue) {
@ -593,6 +1158,24 @@ int bg_team_leave(map_session_data *sd, bool quit, bool deserter)
			}
		}

+		// Extended Battleground [Easycore]
+		if (bgteam->leader_char_id == sd->status.char_id)
+		bgteam->leader_char_id = 0;
+
+		for (const auto &pl_sd : bgteam->members) {
+			if (pl_sd.sd != sd) {
+				if (!bgteam->leader_char_id)
+				{ // Set new Leader first on the list
+					bgteam->leader_char_id = pl_sd.sd->status.char_id;
+					pl_sd.sd->state.bmaster_flag = 1;
+				}
+				// Simulate Guild Information
+				clif_guild_basicinfo(*pl_sd.sd);
+				clif_bg_emblem(pl_sd.sd, bgteam->g);
+				clif_bg_memberlist(pl_sd.sd);
+			}
+		}
+
		char output[CHAT_SIZE_MAX];

		if (quit)
@ -655,6 +1238,7 @@ bool bg_member_respawn(map_session_data *sd)
int bg_create(uint16 mapindex, s_battleground_team* team)
{
	int bg_team_counter = 1;
+	int i;

	while (bg_team_db.find(bg_team_counter) != bg_team_db.end())
		bg_team_counter++;
@ -671,6 +1255,13 @@ int bg_create(uint16 mapindex, s_battleground_team* team)
	bg->die_event = team->death_event.c_str();
	bg->active_event = team->active_event.c_str();

+	//Extended Battleground [Easycore]
+	bg->g = &bg_guild[team->guild_index];
+	bg->color = bg_colors[team->guild_index];
+	bg->afk_warning = true;
+	for( i = 0; i < MAX_GUILDSKILL-1; i++ )
+		bg->skill_block_timer[i] = INVALID_TIMER;
+
	return bg->id;
}

@ -707,6 +1298,13 @@ int bg_team_get_id(struct block_list *bl)
			if( ((TBL_MER*)bl)->master )
				return ((TBL_MER*)bl)->master->bg_id;
			break;
+		case BL_ELEM:
+			if( ((TBL_ELEM*)bl)->master )
+				return ((TBL_ELEM*)bl)->master->bg_id;
+			break;
+		case BL_NPC:
+			return ((TBL_NPC*)bl)->u.scr.bg_id;
+			break;
		case BL_SKILL:
			return ((TBL_SKILL*)bl)->group->bg_id;
	}
@ -742,15 +1340,40 @@ void bg_send_message(map_session_data *sd, const char *mes, int len)
int bg_send_xy_timer_sub(std::shared_ptr<s_battleground_data> bg)
{
	map_session_data *sd;
+	// Extended Battleground [Easycore]
+	char output[128];
+	int idle_announce = battle_config.bg_idle_announce,
+		idle_autokick = battle_config.bg_idle_autokick;

	for (auto &pl_sd : bg->members) {
		sd = pl_sd.sd;

+		// Extended Battleground [Easycore]
+		if (bg->afk_warning && idle_autokick && DIFF_TICK(last_tick, sd->idletime) >= idle_autokick
+			&& bg->g && map_getmapflag(sd->bl.m, MF_BATTLEGROUND))
+		{
+			sprintf(output, msg_txt(sd, 2000), sd->status.name); // [Battlegrounds] %s has been kicked for being AFK
+			clif_broadcast2(&sd->bl, output, (int)strlen(output) + 1, bg->color, 0x190, 20, 0, 0, BG);
+
+			bg_team_leave(sd, true, true);
+
+			clif_displaymessage(sd->fd, msg_txt(sd, 2001)); // You have been kicked from Battleground for your AFK status
+		}
+
		if (sd->bl.x != pl_sd.x || sd->bl.y != pl_sd.y) { // xy update
			pl_sd.x = sd->bl.x;
			pl_sd.y = sd->bl.y;
			clif_bg_xy(sd);
		}
+		if (bg->reveal_pos && bg_player_is_in_bg_map(sd))
+			map_foreachinmap(bg_reveal_pos, sd->bl.m, BL_PC, sd, 1, bg->color);
+		// Message for AFK Idling
+		if (bg->afk_warning && idle_announce && DIFF_TICK(last_tick, sd->idletime) >= idle_announce && !sd->state.bg_afk && bg->g)
+		{ // Set AFK status and announce to the team.
+			sd->state.bg_afk = 1;
+			sprintf(output, msg_txt(sd, 2002), bg->g->name, sd->status.name); //%s : %s seems to be away. AFK Warning - player can be kicked by @reportafk command
+			clif_bg_message(bg.get(), 0, bg->g->name, output, strlen(output) + 1);
+		}
	}

	return 0;
@ -926,6 +1549,13 @@ bool bg_queue_check_joinable(std::shared_ptr<s_battleground_type> bg, map_sessio
		}
	}

+	// Extended Battleground [Easycore]
+	if (battle_config.bg_double_login && bg_countlogin(sd)) {
+		clif_bg_queue_apply_result(BG_APPLY_NONE, name, sd);
+		clif_displaymessage(sd->fd, msg_txt(sd, 2003)); // Double Login [Easycore]
+		return false;
+	}
+
	if (bg->min_lvl > 0 && sd->status.base_level < bg->min_lvl) { // Check minimum level requirement
		clif_bg_queue_apply_result(BG_APPLY_PLAYER_LEVEL, name, sd);
		return false;
@ -970,6 +1600,7 @@ bool bg_queue_reservation(const char *name, bool state, bool ended)
			if (map.mapindex == mapindex) {
				map.isReserved = state;
				for (auto &queue : bg_queues) {
+					bg_queue_clear(queue, true);
					if (queue->map == &map) {
						if (ended) // The ended flag is applied from bg_reserve (bg_unbook clears it for the next queue)
							queue->state = QUEUE_STATE_ENDED;
@ -985,6 +1616,69 @@ bool bg_queue_reservation(const char *name, bool state, bool ended)
	return false;
}

+void bg_queue_leave_all()
+{
+	for (auto &queue : bg_queues) {
+		for (const auto &sd : queue->teama_members) {
+			clif_refresh(sd);
+			clif_bg_queue_apply_result(BG_APPLY_QUEUE_FINISHED, "Tierra Gorge", sd);
+			clif_bg_queue_entry_init(sd);
+			sd->bg_queue_id = 0;
+		}
+
+		for (const auto &sd : queue->teamb_members) {
+			clif_refresh(sd);
+			clif_bg_queue_apply_result(BG_APPLY_QUEUE_FINISHED, "Tierra Gorge", sd);
+			clif_bg_queue_entry_init(sd);
+			sd->bg_queue_id = 0;
+		}
+		bg_queue_clear(queue, true);
+	}
+	return;
+}
+
+bool bg_queue_transfer_all(const char* queue_source, const char* queue_dest)
+{
+	if (!battle_config.bg_rotation_mode) {
+		ShowWarning("bg_queue_transfer_all: this function is only available for rotation mode\n");
+		return false;
+	}
+
+	std::shared_ptr<s_battleground_type> bg_sc = bg_search_name(queue_source);
+	std::shared_ptr<s_battleground_type> bg_dst = bg_search_name(queue_dest);
+
+	if (bg_sc == nullptr || bg_dst == nullptr) {
+		ShowWarning("bg_queue_transfer_all: Could not find queue ids\n");
+		return false;
+	}
+
+	std::shared_ptr<s_battleground_queue> q_sc = bg_search_queue_id(bg_sc->id);
+	std::shared_ptr<s_battleground_queue> q_dst = bg_search_queue_id(bg_dst->id);
+
+	if (!q_sc || !q_dst)
+		return false;
+
+	bg_queue_clear(q_dst, true);
+
+	for (const auto &sd : q_sc->teama_members) {
+		q_dst->teama_members.push_back(sd);
+		sd->bg_queue_id = q_dst->queue_id;
+	}
+	for (const auto &sd : q_sc->teamb_members) {
+		q_dst->teamb_members.push_back(sd);
+		sd->bg_queue_id = q_dst->queue_id;
+	}
+
+	bg_queue_clear(q_sc, false);
+	q_sc->teama_members.clear();
+	q_sc->teamb_members.clear();
+	q_sc->teama_members.shrink_to_fit();
+	q_sc->teamb_members.shrink_to_fit();
+	q_sc->accepted_players = 0;
+	q_sc->state = QUEUE_STATE_SETUP;
+	return true;
+}
+
/**
 * Join as an individual into a Battleground
 * @param name: Battleground name
@ -1210,9 +1904,15 @@ void bg_queue_join_multi(const char *name, map_session_data *sd, std::vector <ma
					continue;

				pc_set_bg_queue_timer(pl_sd);
-				clif_bg_queue_lobby_notify(name, pl_sd);
+				if (battle_config.bg_queue_confirmation && battle_config.bg_queue_interface)
+					clif_bg_queue_lobby_notify(name, pl_sd);
+				else
+					bg_queue_on_accept_invite(pl_sd);
			}
-		} else if (queue->state == QUEUE_STATE_SETUP && queue->teamb_members.size() >= bg->required_players && queue->teama_members.size() >= bg->required_players) // Enough players have joined
+		}
+		else if (battle_config.bg_balance_teams && queue->state == QUEUE_STATE_SETUP && (queue->teama_members.size()+queue->teamb_members.size()) >= bg->required_players)
+			bg_queue_on_ready(name, queue);
+		else if (queue->state == QUEUE_STATE_SETUP && queue->teamb_members.size() >= bg->required_players && queue->teama_members.size() >= bg->required_players) // Enough players have joined
			bg_queue_on_ready(name, queue);

		return;
@ -1366,11 +2066,19 @@ bool bg_queue_on_ready(const char *name, std::shared_ptr<s_battleground_queue> q
	queue->state = QUEUE_STATE_SETUP_DELAY;
	queue->tid_expire = add_timer(gettick() + 20000, bg_on_ready_expire, 0, (intptr_t)queue->queue_id);

-	for (const auto &sd : queue->teama_members)
-		clif_bg_queue_lobby_notify(name, sd);
+	for (const auto &sd : queue->teama_members) {
+		if (battle_config.bg_queue_confirmation && battle_config.bg_queue_interface)
+			clif_bg_queue_lobby_notify(name, sd);
+		else
+			bg_queue_on_accept_invite(sd);
+	}

-	for (const auto &sd : queue->teamb_members)
-		clif_bg_queue_lobby_notify(name, sd);
+	for (const auto &sd : queue->teamb_members) {
+		if (battle_config.bg_queue_confirmation && battle_config.bg_queue_interface)
+			clif_bg_queue_lobby_notify(name, sd);
+		else
+			bg_queue_on_accept_invite(sd);
+	}

	return true;
}
@ -1510,6 +2218,15 @@ void bg_queue_on_accept_invite(map_session_data *sd)
	if (queue->state == QUEUE_STATE_ACTIVE) // Battleground is already active
		bg_join_active(sd, queue);
	else if (queue->state == QUEUE_STATE_SETUP_DELAY) {
+		// Extended Battleground [Easycore]
+		if (battle_config.bg_balance_teams) {
+			char output[CHAT_SIZE_MAX];
+			sprintf(output, msg_txt(sd, 2039), queue->accepted_players, queue->required_players * 2); // Waiting for players... (%d/%d)
+			for (const auto &sd : queue->teama_members)
+				clif_showscript(&sd->bl, output, SELF);
+			for (const auto &sd : queue->teamb_members)
+				clif_showscript(&sd->bl, output, SELF);
+		}
		if (queue->accepted_players == queue->required_players * 2) {
			if (queue->tid_expire != INVALID_TIMER) {
				delete_timer(queue->tid_expire, bg_on_ready_expire);
@ -1525,6 +2242,32 @@ void bg_queue_on_accept_invite(map_session_data *sd)
	}
}

+/**
+ * Re order queue list in order to balance by jobs [Easycore]
+ */
+void bg_queue_balance_teams(std::shared_ptr<s_battleground_queue> queue, int bg_team_1, int bg_team_2)
+{
+	std::vector<map_session_data *> list;
+	bool c = false;
+
+	for (const auto &sd : queue->teama_members)
+		list.push_back(sd);
+	for (const auto &sd : queue->teamb_members)
+		list.push_back(sd);
+	
+	std::sort(list.begin(), list.end(),
+		[](map_session_data * a, map_session_data * b) -> bool
+		{ return a->class_&MAPID_UPPERMASK > b->class_&MAPID_UPPERMASK; });
+
+	for (const auto &sd : list) {
+		clif_bg_queue_entry_init(sd);
+		bg_team_join(c?bg_team_1:bg_team_2, sd, true);
+		c = !c;
+	}
+
+	return;
+}
+
/**
 * Begin the Battleground from the given queue
 * @param queue: Battleground queue
@ -1547,17 +2290,26 @@ void bg_queue_start_battleground(std::shared_ptr<s_battleground_queue> queue)
		return;

	uint16 map_idx = queue->map->mapindex;
+	//Extended Battleground [Easycore]
+	queue->map->team1.guild_index = 0;
+	queue->map->team2.guild_index = 1;
+
	int bg_team_1 = bg_create(map_idx, &queue->map->team1);
	int bg_team_2 = bg_create(map_idx, &queue->map->team2);

-	for (const auto &sd : queue->teama_members) {
-		clif_bg_queue_entry_init(sd);
-		bg_team_join(bg_team_1, sd, true);
-	}
+	// Balance Teams
+	if (battle_config.bg_balance_teams)
+		bg_queue_balance_teams(queue, bg_team_1, bg_team_2);
+	else {
+		for (const auto &sd : queue->teama_members) {
+			clif_bg_queue_entry_init(sd);
+			bg_team_join(bg_team_1, sd, true);
+		}

-	for (const auto &sd : queue->teamb_members) {
-		clif_bg_queue_entry_init(sd);
-		bg_team_join(bg_team_2, sd, true);
+		for (const auto &sd : queue->teamb_members) {
+			clif_bg_queue_entry_init(sd);
+			bg_team_join(bg_team_2, sd, true);
+		}
	}

	mapreg_setreg(add_str(queue->map->team1.bg_id_var.c_str()), bg_team_1);
@ -1606,7 +2358,10 @@ void do_init_battleground(void)
	add_timer_func_list(bg_on_ready_loopback, "bg_on_ready_loopback");
	add_timer_func_list(bg_on_ready_expire, "bg_on_ready_expire");
	add_timer_func_list(bg_on_ready_start, "bg_on_ready_start");
+	add_timer_func_list(bg_block_skill_end,"bg_block_skill_end");
	add_timer_interval(gettick() + battle_config.bg_update_interval, bg_send_xy_timer, 0, 0, battle_config.bg_update_interval);
+
+	bg_guild_build_data();
}

/**






+++ src\map\clif.cpp
@@ -488,7 +488,7 @@ int clif_send(const void* buf, int len, struct block_list* bl, enum send_target
	int x0 = 0, x1 = 0, y0 = 0, y1 = 0, fd;
	struct s_mapiterator* iter;

-	if( type != ALL_CLIENT )
+	if( type != ALL_CLIENT && type != BG_LISTEN)
		nullpo_ret(bl);

	sd = BL_CAST(BL_PC, bl);
@ -496,8 +496,11 @@ int clif_send(const void* buf, int len, struct block_list* bl, enum send_target
	switch(type) {

	case ALL_CLIENT: //All player clients.
+	case BG_LISTEN:
		iter = mapit_getallusers();
		while( ( tsd = (map_session_data*)mapit_next( iter ) ) != nullptr ){
+			if (type == BG_LISTEN && tsd->state.bg_listen)
+				continue;
			if( session_isActive( fd = tsd->fd ) ){
				WFIFOHEAD( fd, len );
				memcpy( WFIFOP( fd, 0 ), buf, len );
@ -1088,7 +1091,7 @@ static void clif_set_unit_idle( struct block_list* bl, bool walking, send_target
	map_session_data* sd = BL_CAST( BL_PC, bl );
	status_change* sc = status_get_sc( bl );
	struct view_data* vd = status_get_viewdata( bl );
-	int g_id = status_get_guild_id( bl );
+	int g_id = clif_visual_guild_id(bl);

#if PACKETVER < 20091103
	if( !pcdb_checkid( vd->class_ ) ){
@ -1109,7 +1112,7 @@ static void clif_set_unit_idle( struct block_list* bl, bool walking, send_target
		p.accessory = vd->head_bottom;
		if( bl->type == BL_NPC && vd->class_ == JT_GUILD_FLAG ){
			// The hell, why flags work like this?
-			p.shield = status_get_emblem_id( bl );
+			p.shield = clif_visual_emblem_id(bl);
			p.accessory2 = GetWord( g_id, 1 );
			p.accessory3 = GetWord( g_id, 0 );
		}else{
@ -1121,7 +1124,7 @@ static void clif_set_unit_idle( struct block_list* bl, bool walking, send_target
		p.bodypalette = vd->cloth_color;
		p.headDir = ( sd )? sd->head_dir : 0;
		p.GUID = g_id;
-		p.GEmblemVer = status_get_emblem_id( bl );
+		p.GEmblemVer = clif_visual_emblem_id(bl);
		p.honor = ( sd ) ? sd->status.manner : 0;
		p.virtue = ( sc ) ? sc->opt3 : 0;
		p.isPKModeON = ( sd && sd->status.karma ) ? 1 : 0;
@ -1178,7 +1181,7 @@ static void clif_set_unit_idle( struct block_list* bl, bool walking, send_target
#endif
	if( bl->type == BL_NPC && vd->class_ == JT_GUILD_FLAG ){
		// The hell, why flags work like this?
-		p.accessory = status_get_emblem_id( bl );
+		p.accessory = clif_visual_emblem_id(bl);
		p.accessory2 = GetWord( g_id, 1 );
		p.accessory3 = GetWord( g_id, 0 );
	}else{
@ -1193,7 +1196,7 @@ static void clif_set_unit_idle( struct block_list* bl, bool walking, send_target
	p.robe = vd->robe;
#endif
	p.GUID = g_id;
-	p.GEmblemVer = status_get_emblem_id( bl );
+	p.GEmblemVer = clif_visual_emblem_id(bl);
	p.honor = (sd) ? sd->status.manner : 0;
	p.virtue = (sc) ? sc->opt3 : 0;
	p.isPKModeON = (sd && sd->status.karma) ? 1 : 0;
@ -1253,7 +1256,7 @@ static void clif_spawn_unit( struct block_list *bl, enum send_target target ){
	map_session_data* sd = BL_CAST( BL_PC, bl );
	status_change* sc = status_get_sc( bl );
	struct view_data* vd = status_get_viewdata( bl );
-	int g_id = status_get_guild_id( bl );
+	int g_id = clif_visual_guild_id(bl);

#if PACKETVER < 20091103
	if( !pcdb_checkid( vd->class_ ) ){
@ -1274,7 +1277,7 @@ static void clif_spawn_unit( struct block_list *bl, enum send_target target ){
		p.job = vd->class_;
		if( bl->type == BL_NPC && vd->class_ == JT_GUILD_FLAG ){
			// The hell, why flags work like this?
-			p.shield = status_get_emblem_id( bl );
+			p.shield = clif_visual_emblem_id(bl);
			p.accessory2 = GetWord( g_id, 1 );
			p.accessory3 = GetWord( g_id, 0 );
		}else{
@ -1320,7 +1323,7 @@ static void clif_spawn_unit( struct block_list *bl, enum send_target target ){
#endif
	if( bl->type == BL_NPC && vd->class_ == JT_GUILD_FLAG ){
		// The hell, why flags work like this?
-		p.accessory = status_get_emblem_id( bl );
+		p.accessory = clif_visual_emblem_id(bl);
		p.accessory2 = GetWord( g_id, 1 );
		p.accessory3 = GetWord( g_id, 0 );
	}else{
@ -1335,7 +1338,7 @@ static void clif_spawn_unit( struct block_list *bl, enum send_target target ){
	p.robe = vd->robe;
#endif
	p.GUID = g_id;
-	p.GEmblemVer = status_get_emblem_id( bl );
+	p.GEmblemVer = clif_visual_emblem_id(bl);
	p.honor = (sd) ? sd->status.manner : 0;
	p.virtue = (sc) ? sc->opt3 : 0;
	p.isPKModeON = (sd && sd->status.karma) ? 1 : 0;
@ -1405,7 +1408,7 @@ static void clif_set_unit_walking( struct block_list *bl, map_session_data *tsd,
	status_change* sc = status_get_sc( bl );
	struct view_data* vd = status_get_viewdata( bl );
	struct packet_unit_walking p;
-	int g_id = status_get_guild_id(bl);
+	int g_id = clif_visual_guild_id(bl);

	sd = BL_CAST(BL_PC, bl);

@ -1443,7 +1446,7 @@ static void clif_set_unit_walking( struct block_list *bl, map_session_data *tsd,
	p.robe = vd->robe;
#endif
	p.GUID = g_id;
-	p.GEmblemVer = status_get_emblem_id(bl);
+	p.GEmblemVer = clif_visual_emblem_id(bl);
	p.honor = (sd) ? sd->status.manner : 0;
	p.virtue = (sc) ? sc->opt3 : 0;
	p.isPKModeON = (sd && sd->status.karma) ? 1 : 0;
@ -2253,6 +2256,14 @@ void clif_selllist(map_session_data *sd)
			if( !pc_can_sell_item(sd, &sd->inventory.u.items_inventory[i], nd->subtype))
				continue;

+			if (sd->inventory.u.items_inventory[i].card[0] == CARD0_CREATE)
+			{ // Do not allow sell BG/WoE Consumables
+				if (battle_config.bg_reserved_char_id && MakeDWord(sd->inventory.u.items_inventory[i].card[2], sd->inventory.u.items_inventory[i].card[3]) == battle_config.bg_reserved_char_id)
+					continue;
+				if (battle_config.woe_reserved_char_id && MakeDWord(sd->inventory.u.items_inventory[i].card[2], sd->inventory.u.items_inventory[i].card[3]) == battle_config.woe_reserved_char_id)
+					continue;
+			}
+
			if (battle_config.rental_item_novalue && sd->inventory.u.items_inventory[i].expire_time)
				val = 0;
			else {
@ -8748,6 +8759,11 @@ void clif_guild_created(map_session_data *sd,int flag)
///     &0x01 = allow invite
///     &0x10 = allow expel
void clif_guild_belonginfo( map_session_data& sd ){
+	if (sd.bg_id ) {
+		clif_bg_belonginfo(&sd);
+		return;
+	}
+
	if( sd.guild == nullptr ){
		return;
	}
@ -8878,9 +8894,12 @@ void clif_guild_masterormember(map_session_data *sd)
/// 01b6 <guild id>.L <level>.L <member num>.L <member max>.L <exp>.L <max exp>.L <points>.L <honor>.L <virtue>.L <emblem id>.L <name>.24B <master name>.24B <manage land>.16B <zeny>.L (ZC_GUILD_INFO2)
/// 0a84 <guild id>.L <level>.L <member num>.L <member max>.L <exp>.L <max exp>.L <points>.L <honor>.L <virtue>.L <emblem id>.L <name>.24B <manage land>.16B <zeny>.L <master char id>.L (ZC_GUILD_INFO3)
void clif_guild_basicinfo( map_session_data& sd ){
-	if( sd.guild == nullptr ){
+	if (sd.bg_id) {
+		clif_bg_basicinfo(sd);
		return;
	}
+	else if (sd.guild == nullptr)
+		return;

	struct guild& guild = *sd.guild;
	struct PACKET_ZC_GUILD_INFO p = {};
@ -8921,7 +8940,11 @@ void clif_guild_allianceinfo(map_session_data *sd)
	struct guild *g;

	nullpo_retv(sd);
-	if( (g = sd->guild) == NULL )
+	if (sd->bg_id)
+		g = bg_guild_get(sd->bg_id);
+	else
+		g = sd->guild;
+	if (g == NULL)
		return;

	fd = sd->fd;
@ -8950,6 +8973,10 @@ void clif_guild_allianceinfo(map_session_data *sd)
///     probably member's self-introduction (unused, no client UI/packets for editing it)
/// 0aa5 <packet len>.W { <account>.L <char id>.L <hair style>.W <hair color>.W <gender>.W <class>.W <level>.W <contrib exp>.L <state>.L <position>.L <lastlogin>.L }* (ZC_MEMBERMGR_INFO2)
void clif_guild_memberlist( map_session_data& sd ){
+	if (sd.bg_id ) {
+		clif_bg_memberlist(&sd);
+		return;
+	}
	if( sd.guild == nullptr ){
		return;
	}
@ -9005,7 +9032,11 @@ void clif_guild_positionnamelist(map_session_data *sd)
	struct guild *g;

	nullpo_retv(sd);
-	if( (g = sd->guild) == NULL )
+	if (sd->bg_id)
+		g = bg_guild_get(sd->bg_id);
+	else
+		g = sd->guild;
+	if (g == NULL)
		return;

	fd = sd->fd;
@ -9033,7 +9064,11 @@ void clif_guild_positioninfolist(map_session_data *sd)
	struct guild *g;

	nullpo_retv(sd);
-	if( (g = sd->guild) == NULL )
+	if (sd->bg_id)
+		g = bg_guild_get(sd->bg_id);
+	else
+		g = sd->guild;
+	if (g == NULL)
		return;

	fd = sd->fd;
@ -9138,8 +9173,8 @@ void clif_guild_emblem_area(struct block_list* bl)
	PACKET_ZC_CHANGE_GUILD p{};

	p.packetType = HEADER_ZC_CHANGE_GUILD;
-	p.guild_id = status_get_guild_id(bl);
-	p.emblem_id = status_get_emblem_id(bl);
+	p.guild_id = clif_visual_guild_id(bl);
+	p.emblem_id = clif_visual_emblem_id(bl);

#if PACKETVER < 20190724
	p.aid = bl->id;
@ -9160,7 +9195,11 @@ void clif_guild_skillinfo(map_session_data* sd)
	int i,c;

	nullpo_retv(sd);
-	if( (g = sd->guild) == NULL )
+	if (sd->bg_id)
+		g = bg_guild_get(sd->bg_id);
+	else
+		g = sd->guild;
+	if (g == NULL)
		return;

	fd = sd->fd;
@ -10059,7 +10098,16 @@ void clif_name( struct block_list* src, struct block_list *bl, send_target targe
				safestrncpy( packet.party_name, p->party.name, NAME_LENGTH );
			}

-			if( sd->guild ){
+			// Extended Battleground [Easycore]
+			if (sd->bg_id)
+			{
+				struct guild *g = bg_guild_get(sd->bg_id);
+				int ps = -1;
+				ps = sd->state.bmaster_flag ? 0 : 1;
+				safestrncpy( packet.guild_name, g->name, NAME_LENGTH );
+				safestrncpy( packet.position_name, g->position[ps].name, NAME_LENGTH );
+			}
+			else if( sd->guild ){
				int position;

				// Will get the position of the guild the player is in
@ -11480,6 +11528,8 @@ void clif_parse_WalkToXY(int fd, map_session_data *sd)
	//Set last idle time... [Skotlex]
	if (battle_config.idletime_option&IDLE_WALK)
		sd->idletime = last_tick;
+	if (sd->bg_id)
+		pc_update_last_action(sd);
	if (battle_config.hom_idle_no_share && sd->hd && battle_config.idletime_hom_option&IDLE_WALK)
		sd->idletime_hom = last_tick;
	if (battle_config.mer_idle_no_share && sd->md && battle_config.idletime_mer_option&IDLE_WALK)
@ -11779,6 +11829,8 @@ void clif_parse_ActionRequest_sub(map_session_data *sd, int action_type, int tar
		pc_delinvincibletimer(sd);
		if (battle_config.idletime_option&IDLE_ATTACK)
			sd->idletime = last_tick;
+		if (sd->bg_id)
+			pc_update_last_action(sd);
		if (battle_config.hom_idle_no_share && sd->hd && battle_config.idletime_hom_option&IDLE_ATTACK)
			sd->idletime_hom = last_tick;
		if (battle_config.mer_idle_no_share && sd->md && battle_config.idletime_mer_option&IDLE_ATTACK)
@ -11813,6 +11865,8 @@ void clif_parse_ActionRequest_sub(map_session_data *sd, int action_type, int tar

		if (battle_config.idletime_option&IDLE_SIT)
			sd->idletime = last_tick;
+		if (sd && sd->bg_id)
+			pc_update_last_action(sd);
		if (battle_config.hom_idle_no_share && sd->hd && battle_config.idletime_hom_option&IDLE_SIT)
			sd->idletime_hom = last_tick;
		if (battle_config.mer_idle_no_share && sd->md && battle_config.idletime_mer_option&IDLE_SIT)
@ -11840,6 +11894,8 @@ void clif_parse_ActionRequest_sub(map_session_data *sd, int action_type, int tar
		if (pc_setstand(sd, false)) {
			if (battle_config.idletime_option&IDLE_SIT)
				sd->idletime = last_tick;
+			if (sd && sd->bg_id)
+				pc_update_last_action(sd);
			if (battle_config.hom_idle_no_share && sd->hd && battle_config.idletime_hom_option&IDLE_SIT)
				sd->idletime_hom = last_tick;
			if (battle_config.mer_idle_no_share && sd->md && battle_config.idletime_mer_option&IDLE_SIT)
@ -12097,6 +12153,8 @@ void clif_parse_DropItem(int fd, map_session_data *sd){

		if (battle_config.idletime_option&IDLE_DROPITEM)
			sd->idletime = last_tick;
+		if (sd && sd->bg_id)
+			pc_update_last_action(sd);
		if (battle_config.hom_idle_no_share && sd->hd && battle_config.idletime_hom_option&IDLE_DROPITEM)
			sd->idletime_hom = last_tick;
		if (battle_config.mer_idle_no_share && sd->md && battle_config.idletime_mer_option&IDLE_DROPITEM)
@ -12131,6 +12189,8 @@ void clif_parse_UseItem(int fd, map_session_data *sd)
	//Whether the item is used or not is irrelevant, the char ain't idle. [Skotlex]
	if (battle_config.idletime_option&IDLE_USEITEM)
		sd->idletime = last_tick;
+	if (sd && sd->bg_id)
+		pc_update_last_action(sd);
	if (battle_config.hom_idle_no_share && sd->hd && battle_config.idletime_hom_option&IDLE_USEITEM)
		sd->idletime_hom = last_tick;
	if (battle_config.mer_idle_no_share && sd->md && battle_config.idletime_mer_option&IDLE_USEITEM)
@ -12183,6 +12243,8 @@ void clif_parse_EquipItem(int fd,map_session_data *sd)

	if (battle_config.idletime_option&IDLE_USEITEM)
		sd->idletime = last_tick;
+	if (sd && sd->bg_id)
+		pc_update_last_action(sd);
	if (battle_config.hom_idle_no_share && sd->hd && battle_config.idletime_hom_option&IDLE_USEITEM)
		sd->idletime_hom = last_tick;
	if (battle_config.mer_idle_no_share && sd->md && battle_config.idletime_mer_option&IDLE_USEITEM)
@ -12924,6 +12986,8 @@ void clif_parse_skill_toid( map_session_data* sd, uint16 skill_id, uint16 skill_
	// This is done here, because homunculi and mercenaries can be triggered by AI and not by the player itself
	if (battle_config.idletime_option&IDLE_USESKILLTOID)
		sd->idletime = last_tick;
+	if (sd && sd->bg_id)
+		pc_update_last_action(sd);
	if (battle_config.hom_idle_no_share && sd->hd && battle_config.idletime_hom_option&IDLE_USESKILLTOID)
		sd->idletime_hom = last_tick;
	if (battle_config.mer_idle_no_share && sd->md && battle_config.idletime_mer_option&IDLE_USESKILLTOID)
@ -12994,8 +13058,26 @@ void clif_parse_skill_toid( map_session_data* sd, uint16 skill_id, uint16 skill_
	sd->skillitem = sd->skillitemlv = 0;

-	if( SKILL_CHK_GUILD(skill_id) ) {
+		if( sd->state.gmaster_flag || skill_id == GD_CHARGESHOUT_BEATING )
+		if (sd->bg_id && map_getmapflag(sd->bl.m, MF_BATTLEGROUND)) {
+			std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, sd->bg_id);
+			int idx = skill_id - GD_SKILLBASE;
+			if( idx < 0 || idx >= MAX_GUILDSKILL )
+				skill_lv = 0;
+			if(bg && bg->leader_char_id == sd->status.char_id)
+			{
+				if (bg->skill_block_timer[idx] == INVALID_TIMER)
+					skill_lv = bg_checkskill(bg.get(), skill_id);
+				else
+					skill_lv = 0;
+			}
+			else
+				skill_lv = 0;
+		}
+		else if (sd->state.gmaster_flag || skill_id == GD_CHARGESHOUT_BEATING) {
			skill_lv = guild_checkskill(sd->guild, skill_id);
+			if (guild_skills_timer(sd,skill_id) >= 0)
+				guild_block_skill_status(sd,skill_id);
+		}
		else
			skill_lv = 0;
	} else {
@ -13056,6 +13138,8 @@ static void clif_parse_UseSkillToPosSub(int fd, map_session_data *sd, uint16 ski
	//Whether skill fails or not is irrelevant, the char ain't idle. [Skotlex]
	if (battle_config.idletime_option&IDLE_USESKILLTOPOS)
		sd->idletime = last_tick;
+	if (sd && sd->bg_id)
+		pc_update_last_action(sd);
	if (battle_config.hom_idle_no_share && sd->hd && battle_config.idletime_hom_option&IDLE_USESKILLTOPOS)
		sd->idletime_hom = last_tick;
	if (battle_config.mer_idle_no_share && sd->md && battle_config.idletime_mer_option&IDLE_USESKILLTOPOS)
@ -14298,9 +14382,13 @@ void clif_parse_GuildChangeMemberPosition( int fd, map_session_data *sd ){
void clif_parse_GuildRequestEmblem(int fd,map_session_data *sd)
{
	struct guild* g;
-	int guild_id = RFIFOL(fd,packet_db[RFIFOW(fd,0)].pos[0]);
+	int guild_id = RFIFOL(fd,packet_db[RFIFOW(fd,0)].pos[0]),i;

-	if( (g = guild_search(guild_id)) != NULL )
+	if( guild_id > INT_MAX - 13 && guild_id <= INT_MAX ) {
+		i = (INT_MAX - guild_id);
+		clif_bg_emblem(sd, &bg_guild[i]);
+	}
+	else if( (g = guild_search(guild_id)) != NULL )
		clif_guild_emblem(sd,g);
}

@ -17552,6 +17640,43 @@ void clif_bossmapinfo(map_session_data *sd, struct mob_data *md, enum e_bossmap_
	WFIFOSET(fd,70);
}

+/// Check Equip extended [Easycore]
+/// 0442 <Length>.W <count>.L <Skill_list>.W (ZC_SKILL_SELECT_REQUEST).
+int clif_skill_select_list(map_session_data *sd, map_session_data *tsd) {
+	int i;
+	int fd;
+	unsigned short skills[3];
+	memset(skills, 0, sizeof(skills));
+	skills[0] = CS_EQUIPMENT;
+	skills[1] = CS_BG;
+	skills[2] = CS_WOE;
+
+	nullpo_ret(sd);
+	nullpo_ret(tsd);
+
+	fd = sd->fd;
+
+	if (!fd)
+		return 0;
+	
+	WFIFOHEAD(fd, 8 + 3 * 2);
+	WFIFOW(fd, 0) = 0x442;
+
+	for (i = 0; i < 3; i++)
+		WFIFOW(fd, 8 + i * 2) = skills[i];
+	
+	WFIFOW(fd, 2) = 8 + 3 * 2;
+	WFIFOL(fd, 4) = 3;
+	WFIFOSET(fd, WFIFOW(fd, 2));
+
+	sd->menuskill_id = SC_AUTOSHADOWSPELL;
+	sd->menuskill_val = 3;
+
+	sd->state.check_equip_skill = tsd->status.account_id;
+	sd->state.workinprogress = WIP_DISABLE_ALL;
+
+	return 1;
+}

/// Requesting equip of a player (CZ_EQUIPWIN_MICROSCOPE).
/// 02d6 <account id>.L
@ -17563,6 +17688,11 @@ void clif_parse_ViewPlayerEquip(int fd, map_session_data* sd)
	if (!tsd)
		return;

+	if (battle_config.bg_extended_check_equip) {
+		clif_skill_select_list(sd, tsd);
+		return;
+	}
+
	if (sd->bl.m != tsd->bl.m)
		return;
	else if( tsd->status.show_equip || pc_has_permission(sd, PC_PERM_VIEW_EQUIPMENT) )
@ -18445,6 +18575,11 @@ void clif_parse_bg_queue_apply_request(int fd, map_session_data *sd)

	nullpo_retv(sd);

+	if (battle_config.bg_rotation_mode || !battle_config.bg_queue_interface) {
+		clif_displaymessage(sd->fd, msg_txt(sd,2041));
+		return;
+	}
+
	short type = RFIFOW(fd,2);
	char name[NAME_LENGTH];

@ -18472,6 +18607,9 @@ void clif_parse_bg_queue_apply_request(int fd, map_session_data *sd)
/// 0x8d8 <result>.B <battleground name>.24B (ZC_ACK_ENTRY_QUEUE_APPLY)
void clif_bg_queue_apply_result(e_bg_queue_apply_ack result, const char *name, map_session_data *sd)
{
+	if (!battle_config.bg_queue_interface && result == BG_APPLY_ACCEPT)
+		return;
+
	nullpo_retv(sd);

	int fd = sd->fd;
@ -18479,7 +18617,10 @@ void clif_bg_queue_apply_result(e_bg_queue_apply_ack result, const char *name, m
	WFIFOHEAD(fd, packet_len(0x8d8));
	WFIFOW(fd,0) = 0x8d8;
	WFIFOB(fd,2) = result;
-	safestrncpy(WFIFOCP(fd,3), name, NAME_LENGTH);
+	if (battle_config.bg_rotation_mode)
+		safestrncpy(WFIFOCP(fd,3), "Battleground Arena", NAME_LENGTH);
+	else
+		safestrncpy(WFIFOCP(fd,3), name, NAME_LENGTH);
	WFIFOSET(fd, packet_len(0x8d8));
}

@ -18488,6 +18629,9 @@ void clif_bg_queue_apply_result(e_bg_queue_apply_ack result, const char *name, m
/// 0x8d9 <battleground name>.24B <queue number>.L (ZC_NOTIFY_ENTRY_QUEUE_APPLY)
void clif_bg_queue_apply_notify(const char *name, map_session_data *sd)
{
+	if (!battle_config.bg_queue_interface)
+		return;
+
	nullpo_retv(sd);

	std::shared_ptr<s_battleground_queue> queue = bg_search_queue(sd->bg_queue_id);
@ -18501,7 +18645,10 @@ void clif_bg_queue_apply_notify(const char *name, map_session_data *sd)

	WFIFOHEAD(fd, packet_len(0x8d9));
	WFIFOW(fd,0) = 0x8d9;
-	safestrncpy(WFIFOCP(fd,2), name, NAME_LENGTH);
+	if (battle_config.bg_rotation_mode)
+		safestrncpy(WFIFOCP(fd,2), "Battleground Arena", NAME_LENGTH);
+	else
+		safestrncpy(WFIFOCP(fd,2), name, NAME_LENGTH);
	WFIFOL(fd,2+NAME_LENGTH) = queue->teama_members.size() + queue->teamb_members.size();
	WFIFOSET(fd, packet_len(0x8d9));
}
@ -18510,6 +18657,9 @@ void clif_bg_queue_apply_notify(const char *name, map_session_data *sd)
/// 0x8db <result>.B <battleground name>.24B (ZC_ACK_ENTRY_QUEUE_CANCEL)
void clif_bg_queue_cancel_result(bool success, const char *name, map_session_data *sd)
{
+	if (!battle_config.bg_queue_interface)
+		return;
+
	nullpo_retv(sd);

	int fd = sd->fd;
@ -18525,7 +18675,7 @@ void clif_bg_queue_cancel_result(bool success, const char *name, map_session_dat
/// 0x8da <battleground name>.24B (CZ_REQ_ENTRY_QUEUE_CANCEL)
void clif_parse_bg_queue_cancel_request(int fd, map_session_data *sd)
{
-	if (!battle_config.feature_bgqueue)
+	if (!battle_config.feature_bgqueue || !battle_config.bg_queue_interface)
		return;

	nullpo_retv(sd);
@ -18546,7 +18696,10 @@ void clif_parse_bg_queue_cancel_request(int fd, map_session_data *sd)

	char name[NAME_LENGTH];

-	safestrncpy( name, RFIFOCP( fd, 2 ), NAME_LENGTH );
+	if (battle_config.bg_rotation_mode)
+		safestrncpy( name, "Battleground Arena", NAME_LENGTH );
+	else
+		safestrncpy( name, RFIFOCP( fd, 2 ), NAME_LENGTH );

	clif_bg_queue_cancel_result(success, name, sd);
}
@ -18555,6 +18708,9 @@ void clif_parse_bg_queue_cancel_request(int fd, map_session_data *sd)
/// 0x8df <battleground name>.24B <lobby name>.24B (ZC_NOTIFY_LOBBY_ADMISSION)
void clif_bg_queue_lobby_notify(const char *name, map_session_data *sd)
{
+	if (!battle_config.bg_queue_interface)
+		return;
+
	nullpo_retv(sd);

	int fd = sd->fd;
@ -18589,6 +18745,9 @@ void clif_parse_bg_queue_lobby_reply(int fd, map_session_data *sd)
/// 0x8e1 <result>.B <battleground name>.24B <lobby name>.24B (ZC_REPLY_ACK_LOBBY_ADMISSION)
void clif_bg_queue_ack_lobby(bool result, const char *name, const char *lobbyname, map_session_data *sd)
{
+	if (!battle_config.bg_queue_interface)
+		return;
+
	nullpo_retv(sd);

	int fd = sd->fd;
@ -18605,11 +18764,17 @@ void clif_bg_queue_ack_lobby(bool result, const char *name, const char *lobbynam
/// 0x90a <battleground name>.24B (CZ_REQ_ENTRY_QUEUE_RANKING)
void clif_parse_bg_queue_request_queue_number(int fd, map_session_data *sd)
{
+	if (!battle_config.bg_queue_interface)
+		return;
+
	nullpo_retv(sd);

	char name[NAME_LENGTH];

-	safestrncpy( name, RFIFOCP(fd, 2), NAME_LENGTH );
+	if (battle_config.bg_rotation_mode)
+		safestrncpy( name, "Battleground Arena", NAME_LENGTH );
+	else
+		safestrncpy( name, RFIFOCP(fd, 2), NAME_LENGTH );

	clif_bg_queue_apply_notify(name, sd);
}
@ -18628,6 +18793,185 @@ void clif_bg_queue_entry_init(map_session_data *sd)
	clif_send( &p, sizeof( p ), &sd->bl, SELF );
}

+void clif_bg_memberlist(map_session_data *sd)
+{
+	map_session_data *psd;
+	int fd, c, i;
+	nullpo_retv(sd);
+
+#if PACKETVER < 20161026
+	int cmd = 0x154;
+	int size = 104;
+#else
+	int cmd = 0xaa5;
+	int size = 34;
+#endif
+
+	if((fd = sd->fd) == 0 )
+		return;
+	if(!sd->bg_id)
+		return;
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, sd->bg_id);
+	if (!bg)
+		return;
+
+	WFIFOHEAD(fd,bg->members.size() * 104 + 4);
+	WFIFOW(fd,0) = 0x154;
+	for( i = 0, c = 0; i < bg->members.size(); i++ )
+	{
+		if( (psd = bg->members[i].sd) == NULL )
+			continue;
+		WFIFOL(fd,c*104+ 4) = psd->status.account_id;
+		WFIFOL(fd,c*104+ 8) = psd->status.char_id;
+		WFIFOW(fd,c*104+12) = psd->status.hair;
+		WFIFOW(fd,c*104+14) = psd->status.hair_color;
+		WFIFOW(fd,c*104+16) = psd->status.sex;
+		WFIFOW(fd,c*104+18) = psd->status.class_;
+		WFIFOW(fd,c*104+20) = psd->status.base_level;
+		WFIFOL(fd,c*104+22) = 0; // Exp slot used to show kills
+		WFIFOL(fd,c*104+26) = 1; // Online
+		WFIFOL(fd,c*104+30) = psd->state.bmaster_flag ? 0 : 1; // Position
+		WFIFOL(fd,c*104+34)=(uint32)time(NULL);
+		memcpy(WFIFOP(fd,c*104+84),psd->status.name,NAME_LENGTH);
+		
+		c++;
+	}
+	WFIFOW(fd, 2)=c*104+4;
+	WFIFOSET(fd,WFIFOW(fd,2));
+}
+
+int clif_visual_guild_id(struct block_list *bl)
+{
+	int bg_id;
+	nullpo_ret(bl);
+	if ((bg_id = bg_team_get_id(bl)) == 0)
+		return status_get_guild_id(bl);
+
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_id);
+
+	if (bg && bg->g)
+		return bg->g->guild_id;
+
+	return 0;
+}
+
+int clif_visual_emblem_id(struct block_list *bl)
+{
+	int bg_id;
+	nullpo_ret(bl);
+	if ((bg_id = bg_team_get_id(bl)) == 0)
+		return status_get_emblem_id(bl);
+
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_id);
+
+	if (bg && bg->g)
+		return bg->g->emblem_id;
+
+	return 0;
+}
+
+/// Notifies the client that it is belonging to a guild (ZC_UPDATE_GDID).
+/// 016c <guild id>.L <emblem id>.L <mode>.L <ismaster>.B <inter sid>.L <guild name>.24B
+/// mode:
+///     &0x01 = allow invite
+///     &0x10 = allow expel
+void clif_bg_belonginfo(struct map_session_data *sd)
+{
+	struct guild *guild;
+
+	nullpo_retv(sd);
+
+	if ((guild = bg_guild_get(sd->bg_id)) == NULL)
+		return;
+
+	struct PACKET_ZC_UPDATE_GDID p = {};
+
+	p.PacketType = HEADER_ZC_UPDATE_GDID;
+	p.guildId = guild->guild_id;
+	p.emblemVersion = guild->emblem_id;
+	p.mode = 0;
+	p.isMaster = 0;
+	p.interSid = 0; // InterSID (unknown purpose)
+	safestrncpy( p.guildName, guild->name, sizeof( p.guildName ) );
+#if PACKETVER_MAIN_NUM >= 20220216
+	p.masterGID = guild->member[0].char_id;
+#endif
+
+	clif_send( &p, sizeof( p ), &sd->bl, SELF );
+}
+
+void clif_bg_emblem(struct map_session_data *sd, struct guild *g)
+{
+	int fd;
+
+	nullpo_retv(sd);
+	nullpo_retv(g);
+
+	if( g->emblem_len <= 0 )
+		return;
+
+	fd = sd->fd;
+	WFIFOHEAD(fd,g->emblem_len+12);
+	WFIFOW(fd,0)=0x152;
+	WFIFOW(fd,2)=g->emblem_len+12;
+	WFIFOL(fd,4)=g->guild_id;
+	WFIFOL(fd,8)=g->emblem_id;
+	memcpy(WFIFOP(fd,12),g->emblem_data,g->emblem_len);
+	WFIFOSET(fd,WFIFOW(fd,2));
+}
+
+void clif_bg_leave_single(struct map_session_data *sd, const char *name, const char *mes)
+{
+	int fd;
+	nullpo_retv(sd);
+
+	fd = sd->fd;
+	WFIFOHEAD(fd, 66);
+	WFIFOW(fd, 0) = 0x15a;
+	memcpy(WFIFOP(fd, 2), name, NAME_LENGTH);
+	memcpy(WFIFOP(fd, 26), mes, 40);
+	WFIFOSET(fd, 66);
+}
+
+void clif_bg_basicinfo(map_session_data& sd){
+	if (!sd.bg_id){
+		return;
+	}
+
+	struct guild *guild = bg_guild_get(sd.bg_id);
+	struct PACKET_ZC_GUILD_INFO p = {};
+
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, sd.bg_id);
+	if (!bg)
+		return;
+
+	p.PacketType = HEADER_ZC_GUILD_INFO;
+	p.GDID = guild->guild_id;
+	p.level = guild->guild_lv;
+	p.userNum = bg->members.size();
+	p.maxUserNum = guild->max_member;
+	p.userAverageLevel = guild->average_lv;
+	p.exp = (uint32)cap_value( guild->exp, 0, MAX_GUILD_EXP );
+	p.maxExp = (uint32)cap_value( guild->next_exp, 0, MAX_GUILD_EXP );
+	p.point = 0; // Tax Points
+	p.honor = 0; // Honor: (left) Vulgar [-100,100] Famed (right)
+	p.virtue = 0; // Virtue: (down) Wicked [-100,100] Righteous (up)
+	p.emblemVersion = guild->emblem_id;
+	safestrncpy( p.guildname, guild->name, sizeof( p.guildname ) );
+	safestrncpy( p.manageLand, msg_txt( &sd, 300), sizeof( p.manageLand ) );
+	p.zeny = 0;
+#if PACKETVER >= 20200902
+	p.masterGID = bg->leader_char_id; // leader
+	safestrncpy( p.masterName, guild->master, sizeof( p.masterName ) );
+#elif PACKETVER_MAIN_NUM >= 20161019 || PACKETVER_RE_NUM >= 20160921 || defined(PACKETVER_ZERO)
+	p.masterGID = bg->leader_char_id; // leader
+#else
+	safestrncpy( p.masterName, guild->master, sizeof( p.masterName ) );
+#endif
+
+	clif_send( &p, sizeof( p ), &sd.bl, SELF );
+}

/// Custom Fonts (ZC_NOTIFY_FONT).
/// 02ef <account_id>.L <font id>.W
void clif_font(map_session_data *sd)
@ -19691,6 +20035,43 @@ void clif_parse_SkillSelectMenu(int fd, map_session_data *sd) {
		sd->state.workinprogress = WIP_DISABLE_NONE;
		skill_autospell(sd, RFIFOW(fd, info->pos[1]));
	} else if (sd->menuskill_id == SC_AUTOSHADOWSPELL) {
+		// Check Equip Extended [Easycore]
+		if (sd->state.check_equip_skill) {
+			int skill = RFIFOW(fd, info->pos[1]);
+			struct map_session_data *tsd = map_id2sd(sd->state.check_equip_skill);
+
+			sd->state.check_equip_skill = 0;
+			sd->state.workinprogress = WIP_DISABLE_NONE;
+			clif_menuskill_clear(sd);
+
+			if (!tsd) {
+				clif_displaymessage(fd, msg_txt(sd,2005)); //Player not found.
+				return;
+			}
+
+			if (!(skill >= CS_EQUIPMENT && skill <= CS_WOE))
+				return;
+
+			switch(skill) {
+				case CS_EQUIPMENT:
+					if (sd->bl.m != tsd->bl.m)
+						return;
+					else if( tsd->status.show_equip || pc_has_permission(sd, PC_PERM_VIEW_EQUIPMENT) )
+						clif_viewequip_ack(sd, tsd);
+					else
+						clif_msg(sd, VIEW_EQUIP_FAIL);
+					break;
+				case CS_BG:
+					pc_battle_stats(sd,tsd,1);
+					break;
+				case CS_WOE:
+					pc_battle_stats(sd,tsd,2);
+					break;
+				default:
+					return;
+			}	
+			return;
+		}
		if (pc_istrading(sd)) {
			clif_skill_fail(sd, sd->ud.skill_id, USESKILL_FAIL_LEVEL, 0);
			clif_menuskill_clear(sd);
@ -25141,6 +25522,28 @@ void clif_parse_partybooking_reply( int fd, map_session_data* sd ){
#endif
}

+void clif_rank_info(map_session_data *sd, int points, int total, e_rank ranktype)
+{
+	char message[100];
+
+	switch(ranktype) {
+		case RANK_BG:
+			if( points < 0 )
+				sprintf(message, msg_txt(sd, 2006), points, total); // [Your Battleground Rank -%d = %d points]
+			else
+				sprintf(message, msg_txt(sd, 2007), points, total); // [Your Battleground Rank +%d = %d points]
+			break;
+		case RANK_WOE:
+			if( points < 0 )
+				sprintf(message, msg_txt(sd, 2008), points, total); // [Your War of Emperium Rank -%d = %d points]
+			else
+				sprintf(message, msg_txt(sd, 2009), points, total); // [Your War of Emperium Rank +%d = %d points]
+			break;
+	}
+	clif_displaymessage(sd->fd, message);
+}
+
+
/*==========================================
 * Main client packet processing function
 *------------------------------------------*/

	


+++ src\map\pc.cpp
@@ -93,6 +93,8 @@ int pc_expiration_tid = INVALID_TIMER;
struct fame_list smith_fame_list[MAX_FAME_LIST];
struct fame_list chemist_fame_list[MAX_FAME_LIST];
struct fame_list taekwon_fame_list[MAX_FAME_LIST];
+struct fame_list bg_fame_list[MAX_FAME_LIST];
+struct fame_list woe_fame_list[MAX_FAME_LIST];

const std::string AttendanceDatabase::getDefaultLocation(){
	return std::string(db_path) + "/attendance.yml";
@ -1009,6 +1011,333 @@ void pc_delabyssball( map_session_data& sd, int count ){
	clif_abyssball( sd );
}

+void pc_record_mobkills(map_session_data *sd, struct mob_data *md)
+{
+	nullpo_retv(sd);
+	int type = 0;
+	if (sd->guild && map_flag_gvg2(sd->bl.m) && is_agit_start()) {
+		switch(md->mob_id) {
+		case MOBID_EMPERIUM:
+			pc_addwoepoints(sd,100);
+			add2limit(sd->status.wstats.emperium_kill, 1, USHRT_MAX);
+			break;
+		case 1905:
+			pc_addwoepoints(sd,5);
+			add2limit(sd->status.wstats.barricade_kill, 1, USHRT_MAX);
+			break;
+		case MOBID_GUARDIAN_STONE1:
+		case MOBID_GUARDIAN_STONE2:
+			pc_addwoepoints(sd,10);
+			add2limit(sd->status.wstats.gstone_kill, 1, USHRT_MAX);
+			break;
+		case 1285:
+		case 1286:
+		case 1287:
+		case 1899:
+		case 1900:
+			pc_addwoepoints(sd,10);
+			add2limit(sd->status.wstats.guardian_kill, 1, USHRT_MAX);
+			break;
+		}
+	}
+	return;
+}
+
+void pc_record_damage(struct block_list *src, struct block_list *target, int damage)
+{
+	if (!src || !target || src == target || damage <= 0)
+		return;
+
+	struct block_list *s_bl;
+	struct map_session_data *sd;
+	struct mob_data *md;
+
+	if ((s_bl = battle_get_master(src)) == NULL)
+		s_bl = src;
+
+	if (s_bl->type != BL_PC)
+		return;
+
+	sd = BL_CAST(BL_PC, s_bl);
+
+	switch(target->type) {
+		case BL_PC:
+			if (sd->bg_id && map_getmapflag(src->m, MF_BATTLEGROUND)) {
+				add2limit(sd->status.bgstats.damage_done, damage, UINT_MAX);
+				add2limit(((TBL_PC*)target)->status.bgstats.damage_received, damage, UINT_MAX);
+				if (sd->status.bgstats.top_damage < damage)
+					sd->status.bgstats.top_damage = damage;
+			}
+			else if (map_flag_gvg2(src->m) && is_agit_start()) {
+				add2limit(sd->status.wstats.damage_done, damage, UINT_MAX);
+				add2limit(((TBL_PC*)target)->status.wstats.damage_received, damage, UINT_MAX);
+				if (sd->status.wstats.top_damage < damage)
+					sd->status.wstats.top_damage = damage;
+			}
+			break;
+		case BL_MOB: {
+			if ((md = BL_CAST(BL_MOB, target))== NULL)
+				return;
+			if (sd->bg_id && map_getmapflag(src->m, MF_BATTLEGROUND)) {
+				if (md->mob_id >= 21406 || md->mob_id <= 21408)
+				add2limit(sd->status.bgstats.boss_damage, damage, UINT_MAX);
+			} else if (map_flag_gvg2(src->m) && is_agit_start()) {
+				switch(md->mob_id) {
+					case MOBID_EMPERIUM:
+						add2limit(sd->status.wstats.emperium_damage, damage, UINT_MAX);
+						break;
+					case 1905:
+						add2limit(sd->status.wstats.barricade_damage, damage, UINT_MAX);
+						break;
+					case MOBID_GUARDIAN_STONE1:
+					case MOBID_GUARDIAN_STONE2:
+						add2limit(sd->status.wstats.gstone_damage, damage, UINT_MAX);
+						break;
+					default:
+						add2limit(sd->status.wstats.guardian_damage, damage, UINT_MAX);
+						break;
+				}
+			}
+			break;
+		}
+	}
+}
+
+void pc_rank_reset(int type)
+{
+	map_session_data *sd = NULL;
+	struct s_mapiterator* iter = NULL;
+	int i;
+
+	iter = mapit_getallusers();
+	for (sd = (TBL_PC*)mapit_first(iter); mapit_exists(iter); sd = (TBL_PC*)mapit_next(iter))	
+	{
+		switch(type) {
+			case RANK_BG: // Battleground Stats}
+				sd->status.bgstats.points = 0;
+				chrif_save(sd, CSAVE_NORMAL);
+				break;
+			case RANK_WOE: // WoE Ranking Reset
+				sd->status.wstats.points = 0;
+				chrif_save(sd, CSAVE_NORMAL);
+				break;
+		}
+	}
+	mapit_free(iter);
+
+	switch(type) {
+		case RANK_BG:
+			if( SQL_ERROR == Sql_Query(mmysql_handle, "UPDATE `char_bg` SET `points` = '0'") )
+				Sql_ShowDebug(mmysql_handle);
+			break;
+		case RANK_WOE:
+			if( SQL_ERROR == Sql_Query(mmysql_handle, "UPDATE `char_wstats` SET `points` = '0'") )
+				Sql_ShowDebug(mmysql_handle);
+			break;
+	}
+
+	chrif_buildfamelist();
+}
+
+void pc_battle_stats(map_session_data *sd, map_session_data *tsd, int flag)
+{
+	if (!sd || !tsd)
+		return;
+
+	char output[CHAT_SIZE_MAX];
+
+	// Battleground Stats
+	if (flag == 1) {
+		if (sd != tsd && tsd->status.bgstats.showstats) {
+			clif_displaymessage(sd->fd, "Player doesn not allow to show this information");
+			return;
+		}
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "============ BATTLEGROUND STATS ============", false, SELF);
+		sprintf(output, "    Name: %s (%s)", tsd->status.name,job_name(tsd->status.class_)); clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		if (pc_famerank(tsd->status.char_id,-1))
+			sprintf(output, "    Rank: %d    -    Points: %d", pc_famerank(tsd->status.char_id,-1),tsd->status.bgstats.points);
+		else
+			sprintf(output, "    Rank: N/A    -    Points: %d",tsd->status.bgstats.points);
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		sprintf(output, "    Wins: %d    -    Lost: %d    -    Draw: %d",tsd->status.bgstats.win,tsd->status.bgstats.lost,tsd->status.bgstats.tie);
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		sprintf(output, "    Kills: %d    -    Deaths: %d", tsd->status.bgstats.kill_count, tsd->status.bgstats.death_count);
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		sprintf(output, "    Damage dealt: %d    -    Top damage: %d", tsd->status.bgstats.damage_done,tsd->status.bgstats.top_damage);
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		sprintf(output, "    Damage received: %d    -    Healing done: %d", tsd->status.bgstats.damage_received, tsd->status.bgstats.healing_done);
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		sprintf(output, "    Deserter times: %d", tsd->status.bgstats.deserter);
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		sprintf(output, "    HP Potions: %d    -    SP Potions: %d", tsd->status.bgstats.hp_heal_potions, tsd->status.bgstats.sp_heal_potions);
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		sprintf(output, "    SP used: %d", tsd->status.bgstats.sp_used);
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		if (tsd->status.bgstats.yellow_gemstones || tsd->status.bgstats.red_gemstones|| tsd->status.bgstats.blue_gemstones) {
+			sprintf(output, "    Yellow G.: %d    -    Red G.: %d    -    Blue G.: %d", tsd->status.bgstats.yellow_gemstones, tsd->status.bgstats.red_gemstones, tsd->status.bgstats.blue_gemstones);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.poison_bottles) {
+			sprintf(output, "    Poison Bottles: %d", tsd->status.bgstats.poison_bottles);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.zeny_used || tsd->status.bgstats.spiritb_used || tsd->status.bgstats.ammo_used) {
+			sprintf(output, "    Zeny used: %d    -    Spirit Ball: %d    -    Ammo used: %d", tsd->status.bgstats.zeny_used, tsd->status.bgstats.spiritb_used, tsd->status.bgstats.ammo_used);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.leader_win || tsd->status.bgstats.leader_lost || tsd->status.bgstats.leader_tie) {
+			sprintf(output, "    Leader wins: %d    -    Leader lost: %d    -    Leader draw: %d", tsd->status.bgstats.leader_win, tsd->status.bgstats.leader_lost, tsd->status.bgstats.leader_tie);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.ti_wins || tsd->status.bgstats.ti_lost || tsd->status.bgstats.ti_tie) {
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "___________ Triple Inferno ___________", false, SELF);
+			sprintf(output, "    Wins: %d    -    Lost: %d    -    Draw: %d", tsd->status.bgstats.ti_wins, tsd->status.bgstats.ti_lost, tsd->status.bgstats.ti_tie);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Skulls (points): %d", tsd->status.bgstats.skulls);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.eos_wins || tsd->status.bgstats.eos_lost || tsd->status.bgstats.eos_tie) {
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "___________ Eye of the Storm ___________", false, SELF);
+			sprintf(output, "    Wins: %d    -    Lost: %d    -    Draw: %d", tsd->status.bgstats.eos_wins, tsd->status.bgstats.eos_lost, tsd->status.bgstats.eos_tie);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Flags: %d    -    Bases: %d", tsd->status.bgstats.eos_flags, tsd->status.bgstats.eos_bases);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.boss_wins || tsd->status.bgstats.boss_lost || tsd->status.bgstats.boss_tie) {
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "___________ Tierra Bossnia ___________", false, SELF);
+			sprintf(output, "    Wins: %d    -    Lost: %d    -    Draw: %d", tsd->status.bgstats.boss_wins, tsd->status.bgstats.boss_lost, tsd->status.bgstats.boss_tie);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Boss kills: %d    -    Boss damage: %d    -    Flags: %d", tsd->status.bgstats.boss_killed, tsd->status.bgstats.eos_bases, tsd->status.bgstats.boss_flags);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.td_wins || tsd->status.bgstats.td_lost || tsd->status.bgstats.td_tie) {
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "___________ Team Deathmatch ___________", false, SELF);
+			sprintf(output, "    Wins: %d    -    Lost: %d    -    Draw: %d", tsd->status.bgstats.td_wins, tsd->status.bgstats.td_lost, tsd->status.bgstats.td_tie);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Kills: %d    -    Deaths: %d", tsd->status.bgstats.td_kills, tsd->status.bgstats.td_deaths);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.dom_wins || tsd->status.bgstats.dom_lost || tsd->status.bgstats.dom_tie) {
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "___________ Domination ___________", false, SELF);
+			sprintf(output, "    Wins: %d    -    Lost: %d    -    Draw: %d", tsd->status.bgstats.dom_wins, tsd->status.bgstats.dom_lost, tsd->status.bgstats.dom_tie);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Offensive Kills: %d    -    Defensive Kills: %d", tsd->status.bgstats.dom_off_kills, tsd->status.bgstats.dom_def_kills);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Bases: %d", tsd->status.bgstats.dom_bases);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.sc_wins || tsd->status.bgstats.sc_lost || tsd->status.bgstats.sc_tie) {
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "___________ Stone Control ___________", false, SELF);
+			sprintf(output, "    Wins: %d    -    Lost: %d    -    Draw: %d", tsd->status.bgstats.sc_wins, tsd->status.bgstats.sc_lost, tsd->status.bgstats.sc_tie);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Captures: %d    -    Stone Stolen: %d-    Stone Dropped: %d", tsd->status.bgstats.sc_captured, tsd->status.bgstats.sc_stole, tsd->status.bgstats.sc_droped);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.ctf_wins || tsd->status.bgstats.ctf_lost || tsd->status.bgstats.ctf_tie) {
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "___________ Capture the Flag ___________", false, SELF);
+			sprintf(output, "    Wins: %d    -    Lost: %d    -    Draw: %d", tsd->status.bgstats.ctf_wins, tsd->status.bgstats.ctf_lost, tsd->status.bgstats.ctf_tie);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Flag captures: %d    -    Flag taken: %d    -    Flag Dropped: %d", tsd->status.bgstats.ctf_captured, tsd->status.bgstats.ctf_taken, tsd->status.bgstats.ctf_droped);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.cq_wins || tsd->status.bgstats.cq_lost) {
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "___________ Conquest ___________", false, SELF);
+			sprintf(output, "    Wins: %d    -    Lost: %d", tsd->status.bgstats.cq_wins, tsd->status.bgstats.cq_lost);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Emperium kills: %d    -    Barricade Kills: %d", tsd->status.bgstats.emperium_kill, tsd->status.bgstats.barricade_kill);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Guardian Stone kills: %d", tsd->status.bgstats.gstone_kill);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.ru_wins || tsd->status.bgstats.ru_lost) {
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "___________ Rush ___________", false, SELF);
+			sprintf(output, "    Wins: %d    -    Lost: %d", tsd->status.bgstats.ru_wins, tsd->status.bgstats.ru_lost);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Captures: %d", tsd->status.bgstats.ru_captures);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+	// War of Emperium Stats
+	} else {
+		if (sd != tsd && tsd->status.wstats.showstats) {
+			clif_displaymessage(sd->fd, "Player doesn not allow to show this information");
+			return;
+		}
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], "============ WAR OF EMPERIUM STATS ============", false, SELF);
+		sprintf(output, "    Name: %s (%s)", tsd->status.name,job_name(tsd->status.class_));
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		if (pc_famerank(tsd->status.char_id,-2))
+			sprintf(output, "    Rank: %d    -    Points: %d", pc_famerank(tsd->status.char_id,-2),tsd->status.bgstats.points);
+		else
+			sprintf(output, "    Rank: N/A    -    Points: %d",tsd->status.bgstats.points);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		sprintf(output, "    Wins: %d    -    Lost: %d    -    Draw: %d",tsd->status.bgstats.win,tsd->status.bgstats.lost,tsd->status.bgstats.tie);
+		sprintf(output, "    Kills: %d    -    Deaths: %d", tsd->status.wstats.kill_count, tsd->status.wstats.death_count);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		sprintf(output, "    Damage dealt: %d    -    Top damage: %d", tsd->status.wstats.damage_done,tsd->status.wstats.top_damage);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		sprintf(output, "    Damage received: %d    -    Healing done: %d", tsd->status.wstats.damage_received, tsd->status.wstats.healing_done);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		sprintf(output, "    HP Potions: %d    -    SP Potions: %d", tsd->status.wstats.hp_heal_potions, tsd->status.wstats.sp_heal_potions);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		sprintf(output, "    SP used: %d", tsd->status.wstats.sp_used);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		sprintf(output, "    Emperium kills: %d    -    Emperium damage: %d", tsd->status.wstats.emperium_kill, tsd->status.wstats.emperium_damage);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		sprintf(output, "    Barricade kills: %d    -    Barricade damage: %d", tsd->status.wstats.barricade_kill, tsd->status.wstats.barricade_damage);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		sprintf(output, "    Guardian kills: %d    -    Guardian damage: %d", tsd->status.wstats.guardian_kill, tsd->status.wstats.guardian_damage);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		if (tsd->status.wstats.yellow_gemstones || tsd->status.wstats.red_gemstones|| tsd->status.wstats.blue_gemstones) {
+			sprintf(output, "    Yellow G.: %d    -    Red G.: %d    -    Blue G.: %d", tsd->status.wstats.yellow_gemstones, tsd->status.wstats.red_gemstones, tsd->status.wstats.blue_gemstones);
+			clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		}
+		if (tsd->status.wstats.poison_bottles) {
+			sprintf(output, "    Poison Bottles: %d", tsd->status.wstats.poison_bottles);
+			clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		}
+		if (tsd->status.wstats.zeny_used || tsd->status.wstats.spiritb_used || tsd->status.wstats.ammo_used) {
+			sprintf(output, "    Zeny used: %d    -    Spirit Ball: %d    -    Ammo used: %d", tsd->status.wstats.zeny_used, tsd->status.wstats.spiritb_used, tsd->status.wstats.ammo_used);
+			clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		}
+	}
+}
+
+/**
+* Increases a player's battleground points and displays a notice to him
+* @param sd Player
+* @param count BG Point
+*/
+void pc_addbgpoints(map_session_data *sd,int count)
+{
+	nullpo_retv(sd);
+
+	clif_specialeffect(&sd->bl, EF_ENHANCE, SELF);
+	sd->status.bgstats.points += count;
+	if (sd->status.bgstats.points > MAX_FAME)
+		sd->status.bgstats.points = MAX_FAME;
+
+	clif_rank_info(sd,count,sd->status.bgstats.points,RANK_BG);
+	chrif_updatefamelist(*sd, RANK_BG);
+}
+
+/**
+* Increases a player's war of emperium points and displays a notice to him
+* @param sd Player
+* @param count WoE Point
+*/
+void pc_addwoepoints(map_session_data *sd,int count)
+{
+	nullpo_retv(sd);
+
+	clif_specialeffect(&sd->bl, EF_ENHANCE, SELF);
+	sd->status.wstats.points += count;
+	if (sd->status.wstats.points > MAX_FAME)
+		sd->status.wstats.points = MAX_FAME;
+
+	clif_rank_info(sd,count,sd->status.wstats.points,RANK_WOE);
+	chrif_updatefamelist(*sd, RANK_WOE);
+}
+
/**
* Increases a player's fame points and displays a notice to him
* @param sd Player
@ -1046,6 +1375,22 @@ bool pc_addfame(map_session_data &sd, int count)
unsigned char pc_famerank(uint32 char_id, int job)
{
	uint8 i;
+	// Battleground Rank [Easycore]
+	if (job == -1) {
+		for(i = 0; i < MAX_FAME_LIST; i++){
+			if(bg_fame_list[i].id == char_id)
+				return i + 1;
+		}
+		return 0;
+	}
+	// War of Emperium Rank [Easycore]
+	else if (job == -2) {
+		for(i = 0; i < MAX_FAME_LIST; i++){
+			if(woe_fame_list[i].id == char_id)
+				return i + 1;
+		}
+		return 0;
+	}

	switch(job){
		case MAPID_BLACKSMITH: // Blacksmith
@ -5749,9 +6094,18 @@ int pc_getcash(map_session_data *sd, int cash, int points, e_log_pick_type type)
 * @return Stored index in inventory, or -1 if not found.
 **/
short pc_search_inventory(map_session_data *sd, t_itemid nameid) {
-	short i;
+	short i,x,y;
	nullpo_retr(-1, sd);

+	if (map_getmapflag(sd->bl.m, MF_BG_CONSUME)) {
+		ARR_FIND( 0, MAX_INVENTORY, x, sd->inventory.u.items_inventory[x].nameid == nameid && ( MakeDWord(sd->inventory.u.items_inventory[x].card[2], sd->inventory.u.items_inventory[x].card[3]) == battle_config.bg_reserved_char_id ) && (sd->inventory.u.items_inventory[x].amount > 0 || nameid == 0) );
+			if( x < MAX_INVENTORY ) return x;
+	}
+	if (map_getmapflag(sd->bl.m, MF_WOE_CONSUME)) {
+		ARR_FIND( 0, MAX_INVENTORY, y, sd->inventory.u.items_inventory[y].nameid == nameid && ( MakeDWord(sd->inventory.u.items_inventory[y].card[2], sd->inventory.u.items_inventory[y].card[3]) == battle_config.woe_reserved_char_id ) && (sd->inventory.u.items_inventory[y].amount > 0 || nameid == 0) );
+			if( y < MAX_INVENTORY ) return y;
+	}
+
	ARR_FIND( 0, MAX_INVENTORY, i, sd->inventory.u.items_inventory[i].nameid == nameid && (sd->inventory.u.items_inventory[i].amount > 0 || nameid == 0) );
	return ( i < MAX_INVENTORY ) ? i : -1;
}
@ -6273,6 +6627,13 @@ int pc_useitem(map_session_data *sd,int n)
		return 0;
	}

+	if( sd->inventory.u.items_inventory[n].card[0] == CARD0_CREATE) {
+		if (MakeDWord(sd->inventory.u.items_inventory[n].card[2], sd->inventory.u.items_inventory[n].card[3]) == battle_config.bg_reserved_char_id && !map_getmapflag(sd->bl.m, MF_BG_CONSUME))
+			return 0;
+		if (MakeDWord(sd->inventory.u.items_inventory[n].card[2], sd->inventory.u.items_inventory[n].card[3]) == battle_config.woe_reserved_char_id && !map_getmapflag(sd->bl.m, MF_WOE_CONSUME))
+			return 0;
+	}

	sd->itemid = item.nameid;
	sd->itemindex = n;
	if(sd->catch_target_class != PET_CATCH_FAIL) //Abort pet catching.
@ -9689,6 +10050,24 @@ int pc_dead(map_session_data *sd,struct block_list *src)
			// To-do: Receive exp on certain occasions
#endif
		}
+		// Extended Battleground [Easycore]
+		if (sd && sd->bg_id) {
+			achievement_update_objective(sd, AG_BG_DIE, 1, 1);
+			add2limit(sd->status.bgstats.death_count, 1, USHRT_MAX);
+		}
+		if (ssd->bg_id && ssd->bg_id != sd->bg_id) {
+			achievement_update_objective(ssd, AG_BG_DAMAGE, 1, ssd->status.bgstats.damage_done);
+			achievement_update_objective(ssd, AG_BG_KILL, 1, 1);
+			add2limit(ssd->status.bgstats.kill_count, 1, USHRT_MAX);
+		}
+		
+		if (map_flag_gvg2(sd->bl.m) && is_agit_start()) {
+			achievement_update_objective(sd, AG_WOE_DAMAGE, 1, sd->status.wstats.damage_done);
+			achievement_update_objective(sd, AG_WOE_DIE, 1, 1);
+			achievement_update_objective(ssd, AG_WOE_KILL, 1, 1);
+			add2limit(sd->status.wstats.death_count, 1, USHRT_MAX);
+			add2limit(ssd->status.wstats.kill_count, 1, USHRT_MAX);
+		}
	}

	if(battle_config.bone_drop==2
@ -10431,6 +10810,9 @@ int pc_itemheal(map_session_data *sd, t_itemid itemid, int hp, int sp)
		tmp = hp * bonus / 100; // Overflow check
		if (bonus != 100 && tmp > hp)
			hp = tmp;
+		//Extended Features BG [Easycore]
+		if( map_getmapflag(sd->bl.m, MF_BATTLEGROUND) && sd->bg_id )
+			add2limit(sd->status.bgstats.hp_heal_potions, 1, UINT_MAX);
	}
	if (sp) {
		bonus = 100 + (sd->battle_status.int_ * 2) + pc_checkskill(sd, MG_SRECOVERY) * 10 + pc_checkskill(sd, AM_LEARNINGPOTION) * 5;
@ -10453,6 +10835,9 @@ int pc_itemheal(map_session_data *sd, t_itemid itemid, int hp, int sp)
		tmp = sp * bonus / 100; // Overflow check
		if (bonus != 100 && tmp > sp)
			sp = tmp;
+		//Extended Features BG [Easycore]
+		if( map_getmapflag(sd->bl.m, MF_BATTLEGROUND) && sd->bg_id )
+			add2limit(sd->status.bgstats.sp_heal_potions, 1, UINT_MAX);
	}
	if (sd->sc.count) {
		// Critical Wound and Death Hurt stack
@ -11060,6 +11445,12 @@ bool pc_candrop(map_session_data *sd, struct item *item)
		return false;
	if( !pc_can_give_items(sd) || sd->sc.cant.drop) //check if this GM level can drop items
		return false;
+	if( item->card[0] == CARD0_CREATE) {
+		if (MakeDWord(item->card[2], item->card[3]) == battle_config.bg_reserved_char_id)
+			return false;
+		if (MakeDWord(item->card[2], item->card[3]) == battle_config.woe_reserved_char_id)
+			return false;
+	}
	return (itemdb_isdropable(item, pc_get_group_level(sd)));
}

@ -15698,6 +16089,27 @@ uint64 CaptchaDatabase::parseBodyNode(const ryml::NodeRef &node) {
	return 1;
}

+/***********************************************************
+* Update Idle PC Timer
+***********************************************************/
+int pc_update_last_action(map_session_data *sd)
+{
+	if (!sd->bg_id)
+		return 1;
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, sd->bg_id);
+	sd->idletime = last_tick;
+
+	if (bg && sd->state.bg_afk)
+	{ // Battleground AFK announce
+		char output[128];
+		sprintf(output, msg_txt(NULL, 2010), bg->g->name, sd->status.name); // %s : %s is no longer AFK...
+		clif_bg_message(bg.get(), 0, bg->g->name, output, strlen(output) + 1);
+		sd->state.bg_afk = 0;
+	}
+
+	return 1;
+}
+
/*==========================================
 * pc Init/Terminate
 *------------------------------------------*/




	
+++ src\map\skill.cpp
@@ -855,6 +855,24 @@ bool skill_isNotOk(uint16 skill_id, map_session_data *sd)
		return true;
	}

+	// Extended Battleground [Easycore]
+	if (SKILL_CHK_GUILD(skill_id)) {
+		if (sd->bg_id) {
+			std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, sd->bg_id);
+			if (bg && bg_block_skill_status(bg.get(), skill_id))
+				return true;
+			else
+				return false;
+		} else {
+			if (skill_blockpc_get(sd, skill_id) != -1) {
+				char output[CHAT_SIZE_MAX];
+				snprintf(output, sizeof(output), msg_txt(sd, 2040), skill_get_desc(skill_id), guild_skills_timer(sd,skill_id)); // [%s] ready in %ds
+				clif_messagecolor(&sd->bl, color_table[COLOR_RED], output, false, GUILD);
+				return true;
+			}
+		}
+	}
+
	if (skill_blockpc_get(sd, skill_id) != -1){
		clif_skill_fail(sd,skill_id,USESKILL_FAIL_SKILLINTERVAL,0);
		return true;
@ -968,10 +986,14 @@ bool skill_isNotOk(uint16 skill_id, map_session_data *sd)
			break;
		case GD_EMERGENCYCALL:
		case GD_ITEMEMERGENCYCALL:
+			if (map_getmapflag(sd->bl.m, MF_NOECALL)) {
+				clif_displaymessage(sd->fd, msg_txt(sd,2011)); // Cannot use Emergency Call in this map.
+				return true;
+			}
			if (
-				!(battle_config.emergency_call&((is_agit_start())?2:1)) ||
+				!map_getmapflag(sd->bl.m, MF_BATTLEGROUND) && (!(battle_config.emergency_call&((is_agit_start())?2:1)) ||
				!(battle_config.emergency_call&(mapdata_flag_gvg2(mapdata)?8:4)) ||
-				(battle_config.emergency_call&16 && mapdata->flag[MF_NOWARPTO] && !(mapdata->flag[MF_GVG_CASTLE] || mapdata->flag[MF_GVG_TE_CASTLE]))
+				(battle_config.emergency_call&16 && map_getmapflag(sd->bl.m, MF_NOWARPTO) && !(map_getmapflag(sd->bl.m, MF_GVG_CASTLE) || map_getmapflag(sd->bl.m, MF_GVG_TE_CASTLE))))
			)	{
				clif_skill_fail(sd,skill_id,USESKILL_FAIL_LEVEL,0);
				return true;
@ -7233,6 +7255,23 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
			if( tsc && tsc->getSCE(SC_AKAITSUKI) && heal && skill_id != HLIF_HEAL )
				heal = ~heal + 1;
			t_exp heal_get_jobexp = status_heal(bl,heal,0,0);
+			// Extended Features BG [Easycore]
+			if (sd && dstsd) {
+				if (map_getmapflag(src->m, MF_BATTLEGROUND) && sd->bg_id && dstsd->bg_id) {
+					if (sd->bg_id == dstsd->bg_id) {
+						achievement_update_objective(sd, AG_BG_HEAL, 1, heal_get_jobexp);
+						add2limit(sd->status.bgstats.healing_done, heal_get_jobexp, UINT_MAX);
+					} else
+						add2limit(sd->status.bgstats.wrong_healing_done, heal_get_jobexp, UINT_MAX);
+				}
+				else if (is_agit_start() && map_flag_gvg2(src->m) && sd->guild && dstsd->guild) {
+					if (sd->guild == dstsd->guild) {
+						achievement_update_objective(sd, AG_WOE_HEAL, 1, heal_get_jobexp);
+						add2limit(sd->status.wstats.healing_done, heal_get_jobexp, UINT_MAX);
+					} else
+						add2limit(sd->status.wstats.wrong_healing_done, heal_get_jobexp, UINT_MAX);
+				}
+			}

			if(sd && dstsd && heal > 0 && sd != dstsd && battle_config.heal_exp > 0){
				heal_get_jobexp = heal_get_jobexp * battle_config.heal_exp / 100;
@ -7961,6 +8000,8 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui

	case CD_COMPETENTIA:
		if (sd == nullptr || sd->status.party_id == 0 || (flag & 1)) {
+			if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+				break;
			int hp_amount = tstatus->max_hp * (20 * skill_lv) / 100;
			int sp_amount = tstatus->max_sp * (20 * skill_lv) / 100;

@ -7971,8 +8012,11 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
			status_heal(bl, 0, sp_amount, 0);

			clif_skill_nodamage(bl, bl, skill_id, skill_lv, sc_start(src, bl, type, 100, skill_lv, skill_get_time(skill_id, skill_lv)));
-		} else if (sd)
-			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+		}
+		else if (sd && sd->bg_id)
+				map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
+			else if (sd)
+				party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag | BCT_PARTY | 1, skill_castend_nodamage_id);
		break;

	case BO_ADVANCE_PROTECTION:
@ -8237,6 +8281,8 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
			int8 count = min(5 + skill_lv, MAX_UNITED_SOULS);

			if (sd == nullptr || sd->status.party_id == 0 || (flag & 1)) {
+				if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+					break;
				if (!dstsd || !sd) { // Only put player's souls in unity.
					if (sd)
						clif_skill_fail(sd, skill_id, USESKILL_FAIL, 0);
@ -8265,10 +8311,12 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui

					sd->united_soul[i] = bl->id;
				}
-
				clif_skill_nodamage(src, bl, skill_id, skill_lv, sc_start4(src, bl, type, 100, skill_lv, src->id, i, 0, skill_get_time(skill_id, skill_lv)));
-			} else if (sd)
-				party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+			}
+			else if (sd && sd->bg_id)
+				map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
+			else if (sd)
+				party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag | BCT_PARTY | 1, skill_castend_nodamage_id);
		}
		break;

@ -8672,13 +8720,16 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
	case PR_MAGNIFICAT:
	case PR_GLORIA:
		if (sd == NULL || sd->status.party_id == 0 || (flag & 1)) {
-
+			if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+				break;
			// Animations don't play when outside visible range
			if (check_distance_bl(src, bl, AREA_SIZE))
				clif_skill_nodamage(bl, bl, skill_id, skill_lv, 1);

			sc_start(src, bl, type, 100, skill_lv, skill_get_time(skill_id, skill_lv));
		}
+		else if (sd && sd->bg_id)
+			map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
		else if (sd)
			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag | BCT_PARTY | 1, skill_castend_nodamage_id);
		break;
@ -8693,10 +8744,15 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
	case NV_HELPANGEL:
	case IG_GUARDIAN_SHIELD:
	case IG_ULTIMATE_SACRIFICE:// Is the animation on this skill correct? Check if its on caster only or all affected. [Rytech]
-		if( sd == NULL || sd->status.party_id == 0 || (flag & 1) )
+		if( sd == NULL || sd->status.party_id == 0 || (flag & 1) ) {
+			if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+				break;
			clif_skill_nodamage(bl, bl, skill_id, skill_lv, sc_start(src,bl,type,100,skill_lv,skill_get_time(skill_id,skill_lv)));
-		else if (sd)
-		{
+		}
+		else if (sd && sd->bg_id)
+			map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
+		else if (sd) {
+			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag | BCT_PARTY | 1, skill_castend_nodamage_id);
			if (skill_id == IG_ULTIMATE_SACRIFICE)
				status_set_hp(src, 1, 0);
			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
@ -8720,15 +8776,16 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
	case BS_OVERTHRUST:
		if (sd == NULL || sd->status.party_id == 0 || (flag & 1)) {
			int weapontype = skill_get_weapontype(skill_id);
+			if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+				break;
			if (!weapontype || !dstsd || pc_check_weapontype(dstsd, weapontype)) {
				clif_skill_nodamage(bl, bl, skill_id, skill_lv,
					sc_start2(src, bl, type, 100, skill_lv, (src == bl) ? 1 : 0, skill_get_time(skill_id, skill_lv)));
			}
-		} else if (sd) {
-			party_foreachsamemap(skill_area_sub,
-				sd,skill_get_splash(skill_id, skill_lv),
-				src,skill_id,skill_lv,tick, flag|BCT_PARTY|1,
-				skill_castend_nodamage_id);
+		else if (sd && sd->bg_id)
+			map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
+		else if (sd)
+			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag | BCT_PARTY | 1, skill_castend_nodamage_id);
		}
		break;

@ -10128,6 +10185,8 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
		// Updated to block Slim Pitcher from working on barricades and guardian stones.
		if (dstmd && (dstmd->mob_id == MOBID_EMPERIUM || status_get_class_(bl) == CLASS_BATTLEFIELD))
			break;
+		if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+			break;
		if (potion_hp || potion_sp) {
			int hp = potion_hp, sp = potion_sp;
			hp = hp * (100 + (tstatus->vit * 2))/100;
@ -10313,24 +10372,32 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
	case GD_RESTORE:
	case GD_EMERGENCY_MOVE:
		if(flag&1) {
-			if (status_get_guild_id(src) == status_get_guild_id(bl)) {				
+			if (status_get_guild_id(src) == status_get_guild_id(bl) || (map_getmapflag(src->m, MF_BATTLEGROUND) && bg_team_get_id(src) == bg_team_get_id(bl))) {		
				if( skill_id == GD_RESTORE )
					clif_skill_nodamage(src,bl,AL_HEAL,status_percent_heal(bl,90,90),1);
				else
					sc_start(src,bl,type,100,skill_lv,skill_get_time(skill_id, skill_lv));
			}
-		} else if (status_get_guild_id(src)) {
+		} else if (status_get_guild_id(src) || (map_getmapflag(src->m, MF_BATTLEGROUND) && bg_team_get_id(src))) {
			clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
			map_foreachinallrange(skill_area_sub, src,
				skill_get_splash(skill_id, skill_lv), BL_PC,
-				src,skill_id,skill_lv,tick, flag|BCT_GUILD|1,
+				src,skill_id,skill_lv,tick, flag|BCT_NOENEMY|1,
				skill_castend_nodamage_id);
-			if (sd)
+			if (sd) {
+				std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, sd->bg_id);
#ifdef RENEWAL
-				skill_blockpc_start(sd, skill_id, skill_get_cooldown(skill_id, skill_lv));
+				if (bg && sd->bg_id)
+					bg_block_skill_start(bg.get(), skill_id, skill_get_cooldown(skill_id, skill_lv));
+				else
+					skill_blockpc_start(sd, skill_id, skill_get_cooldown(skill_id, skill_lv));
#else
-				guild_block_skill(sd, skill_get_time2(skill_id, skill_lv));
+				if (bg && sd->bg_id)
+					bg_block_skill_start(bg.get(), skill_id, skill_get_time2(skill_id, skill_lv));
+				else
+					guild_block_skill(sd,skill_get_time2(skill_id,skill_lv));
#endif
+			}
		}
		break;
	case GD_EMERGENCYCALL:
@ -10339,10 +10406,17 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
			int8 dx[9] = {-1, 1, 0, 0,-1, 1,-1, 1, 0};
			int8 dy[9] = { 0, 0, 1,-1, 1,-1,-1, 1, 0};
			uint8 j = 0, calls = 0, called = 0;
-			struct guild *g;
-			// i don't know if it actually summons in a circle, but oh well. ;P
-			g = sd?sd->guild:guild_search(status_get_guild_id(src));
-			if (!g)
+			struct guild *g = NULL;
+			std::shared_ptr<s_battleground_data> bg = nullptr;
+			int max_member;
+			if (map_getmapflag(src->m, MF_BATTLEGROUND) && bg_team_get_id(src)) {
+				bg = util::umap_find(bg_team_db, bg_team_get_id(src));
+				max_member = bg->members.size();
+			} else {
+				g = sd?sd->guild:guild_search(status_get_guild_id(src));
+				max_member = g->max_member;
+			}
+			if (!g && !bg)
				break;

			if (skill_id == GD_ITEMEMERGENCYCALL)
@ -10354,11 +10428,11 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
				}

			clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
-			for (i = 0; i < g->max_member && (!calls || (calls && called < calls)); i++, j++) {
+			for (i = 0; i < max_member && (!calls || (calls && called < calls)); i++, j++) {
				if (j > 8)
					j = 0;
-				if ((dstsd = g->member[i].sd) != NULL && sd != dstsd && !dstsd->state.autotrade && !pc_isdead(dstsd)) {
-					if (map_getmapflag(dstsd->bl.m, MF_NOWARP) && !map_flag_gvg2(dstsd->bl.m))
+				if ((dstsd = bg?bg->members[i].sd:g->member[i].sd) != NULL && sd != dstsd && !dstsd->state.autotrade && !pc_isdead(dstsd)) {
+					if (map_getmapflag(dstsd->bl.m, MF_NOWARP) && !map_flag_gvg2(dstsd->bl.m) && !bg)
						continue;
					if (!pc_job_can_entermap((enum e_job)dstsd->status.class_, src->m, pc_get_group_level(dstsd)))
						continue;
@ -10368,12 +10442,19 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
						called++;
				}
			}
-			if (sd)
+			if (sd) {
#ifdef RENEWAL
-				skill_blockpc_start(sd, skill_id, skill_get_cooldown(skill_id, skill_lv));
+				if (sd->bg_id)
+					bg_block_skill_start(bg.get(), skill_id, skill_get_cooldown(skill_id, skill_lv));
+				else
+					skill_blockpc_start(sd, skill_id, skill_get_cooldown(skill_id, skill_lv));
#else
-				guild_block_skill(sd, skill_get_time2(skill_id, skill_lv));
+				if (sd->bg_id)
+					bg_block_skill_start(bg.get(), skill_id, skill_get_time2(skill_id, skill_lv));
+				else
+					guild_block_skill(sd,skill_get_time2(skill_id,skill_lv));
#endif
+			}
		}
		break;
	case GD_CHARGESHOUT_FLAG:
@ -10804,29 +10885,41 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
		{
			int bless_lv = ((sd) ? pc_checkskill(sd,AL_BLESSING) : skill_get_max(AL_BLESSING)) + (((sd) ? sd->status.job_level : 50) / 10);
			int agi_lv = ((sd) ? pc_checkskill(sd,AL_INCAGI) : skill_get_max(AL_INCAGI)) + (((sd) ? sd->status.job_level : 50) / 10);
-			if( sd == NULL || sd->status.party_id == 0 || flag&1 )
+			if( sd == NULL || sd->status.party_id == 0 || flag&1 ) {
+				if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+					break;
				clif_skill_nodamage(bl, bl, skill_id, skill_lv, sc_start(src,bl,type,100,
					(skill_id == AB_CLEMENTIA)? bless_lv : (skill_id == AB_CANTO)? agi_lv : skill_lv, skill_get_time(skill_id,skill_lv)));
-			else if( sd )
-				party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+			}
+			else if (sd && sd->bg_id)
+				map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
+			else if (sd)
+				party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag | BCT_PARTY | 1, skill_castend_nodamage_id);
		}
		break;

	case AB_PRAEFATIO:
	case AB_RENOVATIO:
		if( !sd || sd->status.party_id == 0 || flag&1 ) {
+			if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+				break;
			if (skill_id == AB_PRAEFATIO)
				clif_skill_nodamage(bl, bl, skill_id, skill_lv, sc_start4(src, bl, type, 100, skill_lv, 0, 0, (sd && sd->status.party_id ? party_foreachsamemap(party_sub_count, sd, 0) : 1 ), skill_get_time(skill_id, skill_lv)));
			else
				clif_skill_nodamage(bl, bl, skill_id, skill_lv, sc_start(src, bl, type, 100, skill_lv, skill_get_time(skill_id, skill_lv)));
-		} else if( sd )
-			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+		}
+		else if (sd && sd->bg_id)
+			map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
+		else if (sd)
+			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag | BCT_PARTY | 1, skill_castend_nodamage_id);
		break;

	case AB_CHEAL:
		if( !sd || sd->status.party_id == 0 || flag&1 ) {
			if( sd && tstatus && !battle_check_undead(tstatus->race, tstatus->def_ele) && !tsc->getSCE(SC_BERSERK) ) {
				int partycount = (sd->status.party_id ? party_foreachsamemap(party_sub_count, sd, 0) : 0);
+				if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+					break;

				i = skill_calc_heal(src, bl, AL_HEAL, pc_checkskill(sd, AL_HEAL), true);

@ -10840,8 +10933,11 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
					i = ~i + 1;
				status_heal(bl, i, 0, 0);
			}
-		} else if( sd )
-			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+		}
+		else if (sd && sd->bg_id)
+			map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
+		else if (sd)
+			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag | BCT_PARTY | 1, skill_castend_nodamage_id);
		break;

	case NPC_CHEAL:
@ -10875,6 +10971,8 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui

	case AB_LAUDAAGNUS:
		if( flag&1 || !sd || !sd->status.party_id ) {
+			if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+				break;
			if( tsc && (tsc->getSCE(SC_FREEZE) || tsc->getSCE(SC_STONE) || tsc->getSCE(SC_BLIND) ||
				tsc->getSCE(SC_BURNING) || tsc->getSCE(SC_FREEZING) || tsc->getSCE(SC_CRYSTALIZE))) {
				// Success Chance: (60 + 10 * Skill Level) %
@ -10888,13 +10986,17 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
			} else //Success rate only applies to the curing effect and not stat bonus. Bonus status only applies to non infected targets
				clif_skill_nodamage(bl, bl, skill_id, skill_lv,
					sc_start(src,bl, type, 100, skill_lv, skill_get_time(skill_id, skill_lv)));
-		} else if( sd )
-			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv),
-				src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+		}
+		else if (sd && sd->bg_id)
+			map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
+		else if (sd)
+			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag | BCT_PARTY | 1, skill_castend_nodamage_id);
		break;

	case AB_LAUDARAMUS:
		if( flag&1 || !sd || !sd->status.party_id ) {
+			if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+				break;
			if( tsc && (tsc->getSCE(SC_SLEEP) || tsc->getSCE(SC_STUN) || tsc->getSCE(SC_MANDRAGORA) || tsc->getSCE(SC_SILENCE) || tsc->getSCE(SC_DEEPSLEEP)) ){
				// Success Chance: (60 + 10 * Skill Level) %
				if( rnd()%100 > 60+10*skill_lv )  break;
@ -10906,9 +11008,11 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
			} else // Success rate only applies to the curing effect and not stat bonus. Bonus status only applies to non infected targets
				clif_skill_nodamage(bl, bl, skill_id, skill_lv,
					sc_start(src,bl, type, 100, skill_lv, skill_get_time(skill_id, skill_lv)));
-		} else if( sd )
-			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv),
-				src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+		}
+		else if (sd && sd->bg_id)
+			map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
+		else if (sd)
+			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag | BCT_PARTY | 1, skill_castend_nodamage_id);
		break;

	case AB_CLEARANCE:
@ -11489,10 +11593,17 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
	case MI_RUSH_WINDMILL:
	case MI_ECHOSONG:
		if( !sd || !sd->status.party_id || (flag & 1) ) {
+			if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+				break;
			clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
			sc_start2(src,bl,type,100,skill_lv,((sd) ? pc_checkskill(sd,WM_LESSON) : skill_get_max(WM_LESSON)),skill_get_time(skill_id,skill_lv));
-		} else if( sd ) {
-			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+		}
+		else if (sd && sd->bg_id) {
+			map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
+			sc_start2(src,bl,type,100,skill_lv,((sd) ? pc_checkskill(sd,WM_LESSON) : skill_get_max(WM_LESSON)),skill_get_time(skill_id,skill_lv));
+			clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
+		} else if (sd) {
+			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag | BCT_PARTY | 1, skill_castend_nodamage_id);
			sc_start2(src,bl,type,100,skill_lv,((sd) ? pc_checkskill(sd,WM_LESSON) : skill_get_max(WM_LESSON)),skill_get_time(skill_id,skill_lv));
			clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
		}
@ -11563,10 +11674,17 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
	case WM_UNLIMITED_HUMMING_VOICE:
		if( flag&1 ) {	// These affect to to all party members near the caster.
			status_change *sc = status_get_sc(src);
+			if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+				break;
			if( sc && sc->getSCE(type) ) {
				sc_start2(src,bl,type,100,skill_lv,pc_checkskill(sd, WM_LESSON),skill_get_time(skill_id,skill_lv));
			}
-		} else if( sd ) {
+		}
+		else if (sd && sd->bg_id) {
+			if( sc_start2(src,bl,type,100,skill_lv,pc_checkskill(sd, WM_LESSON),skill_get_time(skill_id,skill_lv)) )
+				party_foreachsamemap(skill_area_sub,sd,skill_get_splash(skill_id,skill_lv),src,skill_id,skill_lv,tick,flag|BCT_PARTY|1,skill_castend_nodamage_id);
+			clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
+		} else if (sd) {
			if( sc_start2(src,bl,type,100,skill_lv,pc_checkskill(sd, WM_LESSON),skill_get_time(skill_id,skill_lv)) )
				party_foreachsamemap(skill_area_sub,sd,skill_get_splash(skill_id,skill_lv),src,skill_id,skill_lv,tick,flag|BCT_PARTY|1,skill_castend_nodamage_id);
			clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
@ -12372,24 +12490,33 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
	case SU_MEOWMEOW:
		if (sd == NULL || sd->status.party_id == 0 || flag&1) {
			int duration = skill_get_time(skill_id, skill_lv);
+			if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+				break;

			if (skill_id == SU_BUNCHOFSHRIMP && pc_checkskill(sd, SU_SPIRITOFSEA))
				duration += skill_get_time2(SU_BUNCHOFSHRIMP, skill_lv);
			clif_skill_nodamage(bl, bl, skill_id, skill_lv, sc_start(src, bl, type, 100, skill_lv, duration));
-		} else if (sd) {
-			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
		}
+		else if (sd && sd->bg_id)
+			map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
+		else if (sd)
+			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag | BCT_PARTY | 1, skill_castend_nodamage_id);
		break;

	case SU_SHRIMPARTY:
		if (sd == NULL || sd->status.party_id == 0 || flag&1) {
+			if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+				break;
			sc_start(src, bl, type, 100, skill_lv, skill_get_time(skill_id, skill_lv));
			if (sd && (i = pc_checkskill(sd, SU_FRESHSHRIMP)) > 0) {
				clif_skill_nodamage(bl, bl, SU_FRESHSHRIMP, i, 1);
				sc_start(src, bl, SC_FRESHSHRIMP, 100, i, skill_get_time(SU_FRESHSHRIMP, i));
			}
-		} else if (sd)
-			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+		}
+		else if (sd && sd->bg_id)
+			map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
+		else if (sd)
+			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag | BCT_PARTY | 1, skill_castend_nodamage_id);
		break;

	case SU_POWEROFFLOCK:
@ -17347,14 +17474,17 @@ bool skill_check_condition_castbegin(map_session_data* sd, uint16 skill_id, uint
		case GD_CHARGESHOUT_FLAG:
		case GD_CHARGESHOUT_BEATING:
		case GD_EMERGENCY_MOVE:
-			if (!map_flag_gvg2(sd->bl.m)) {
+			if (!map_flag_gvg2(sd->bl.m) && !map_getmapflag(sd->bl.m, MF_BATTLEGROUND)) {
				clif_skill_fail(sd,skill_id,USESKILL_FAIL_LEVEL,0);
				return false;
			}
		case GD_EMERGENCYCALL:
		case GD_ITEMEMERGENCYCALL:
			// other checks were already done in skill_isNotOk()
-			if (!sd->status.guild_id || (sd->state.gmaster_flag == 0 && skill_id != GD_CHARGESHOUT_BEATING))
+			if (map_getmapflag(sd->bl.m, MF_BATTLEGROUND)) {
+				if (sd->bg_id && !sd->state.bmaster_flag)
+					return false;
+			} else if (!sd->status.guild_id || (sd->state.gmaster_flag == 0 && skill_id != GD_CHARGESHOUT_BEATING))
				return false;
			break;

@ -18179,7 +18309,13 @@ bool skill_check_condition_castend(map_session_data* sd, uint16 skill_id, uint16
		if( !require.itemid[i] )
			continue;
		index[i] = pc_search_inventory(sd,require.itemid[i]);
-		if( index[i] < 0 || sd->inventory.u.items_inventory[index[i]].amount < require.amount[i] ) {
+		if( index[i] < 0 || sd->inventory.u.items_inventory[index[i]].amount < require.amount[i] ||
+			sd->inventory.u.items_inventory[index[i]].card[0] == CARD0_CREATE && 
+			((MakeDWord(sd->inventory.u.items_inventory[index[i]].card[2], sd->inventory.u.items_inventory[index[i]].card[3]) == 
+			battle_config.bg_reserved_char_id && !map_getmapflag(sd->bl.m, MF_BG_CONSUME)) ||
+			(MakeDWord(sd->inventory.u.items_inventory[index[i]].card[2], sd->inventory.u.items_inventory[index[i]].card[3]) == 
+			battle_config.woe_reserved_char_id && !map_getmapflag(sd->bl.m, MF_WOE_CONSUME)))
+		) {
			if( require.itemid[i] == ITEMID_HOLY_WATER )
				clif_skill_fail(sd,skill_id,USESKILL_FAIL_HOLYWATER,0); //Holy water is required.
			else if( require.itemid[i] == ITEMID_RED_GEMSTONE )
@ -18194,6 +18330,15 @@ bool skill_check_condition_castend(map_session_data* sd, uint16 skill_id, uint16
				clif_skill_fail( sd, skill_id, USESKILL_FAIL_NEED_ITEM, require.amount[i], require.itemid[i] ); // [%s] required '%d' amount.
			return false;
		}
+		if (sd->inventory.u.items_inventory[index[i]].card[0] == CARD0_CREATE && 
+			((MakeDWord(sd->inventory.u.items_inventory[index[i]].card[2], sd->inventory.u.items_inventory[index[i]].card[3]) == 
+			battle_config.bg_reserved_char_id && !map_getmapflag(sd->bl.m, MF_BG_CONSUME)) ||
+			(MakeDWord(sd->inventory.u.items_inventory[index[i]].card[2], sd->inventory.u.items_inventory[index[i]].card[3]) == 
+			battle_config.woe_reserved_char_id && !map_getmapflag(sd->bl.m, MF_WOE_CONSUME)))) {
+				clif_skill_fail( sd, skill_id, USESKILL_FAIL_NEED_ITEM, require.amount[i], require.itemid[i] ); // [%s] required '%d' amount.
+				clif_messagecolor(&sd->bl, color_table[COLOR_WHITE], "No puedes utilizar un item de BG/WoE en este mapa.", false, SELF);
+				return false;
+			}
	}

	/* check the status required */
@ -19503,6 +19648,9 @@ int skill_frostjoke_scream(struct block_list *bl, va_list ap)
		if ( sd && sd->sc.option&(OPTION_INVISIBLE|OPTION_MADOGEAR) )
			return 0;//Frost Joke / Scream cannot target invisible or MADO Gear characters [Ind]
	}
+	// Extended Battleground [Easycore]
+	if (map_getmapflag(bl->m, MF_BATTLEGROUND) && map_getcell(bl->m, bl->x, bl->y, CELL_CHKBASILICA))
+		return 0;
	//It has been reported that Scream/Joke works the same regardless of woe-setting. [Skotlex]
	if(battle_check_target(src,bl,BCT_ENEMY) > 0)
		skill_additional_effect(src,bl,skill_id,skill_lv,BF_MISC,ATK_DEF,tick);
		
		