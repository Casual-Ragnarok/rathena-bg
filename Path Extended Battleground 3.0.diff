
@ -18488,6 +18629,9 @@ void clif_bg_queue_apply_result(e_bg_queue_apply_ack result, const char *name, m
/// 0x8d9 <battleground name>.24B <queue number>.L (ZC_NOTIFY_ENTRY_QUEUE_APPLY)
void clif_bg_queue_apply_notify(const char *name, map_session_data *sd)
{
+	if (!battle_config.bg_queue_interface)
+		return;
+
	nullpo_retv(sd);

	std::shared_ptr<s_battleground_queue> queue = bg_search_queue(sd->bg_queue_id);
@ -18501,7 +18645,10 @@ void clif_bg_queue_apply_notify(const char *name, map_session_data *sd)

	WFIFOHEAD(fd, packet_len(0x8d9));
	WFIFOW(fd,0) = 0x8d9;
-	safestrncpy(WFIFOCP(fd,2), name, NAME_LENGTH);
+	if (battle_config.bg_rotation_mode)
+		safestrncpy(WFIFOCP(fd,2), "Battleground Arena", NAME_LENGTH);
+	else
+		safestrncpy(WFIFOCP(fd,2), name, NAME_LENGTH);
	WFIFOL(fd,2+NAME_LENGTH) = queue->teama_members.size() + queue->teamb_members.size();
	WFIFOSET(fd, packet_len(0x8d9));
}
@ -18510,6 +18657,9 @@ void clif_bg_queue_apply_notify(const char *name, map_session_data *sd)
/// 0x8db <result>.B <battleground name>.24B (ZC_ACK_ENTRY_QUEUE_CANCEL)
void clif_bg_queue_cancel_result(bool success, const char *name, map_session_data *sd)
{
+	if (!battle_config.bg_queue_interface)
+		return;
+
	nullpo_retv(sd);

	int fd = sd->fd;
@ -18525,7 +18675,7 @@ void clif_bg_queue_cancel_result(bool success, const char *name, map_session_dat
/// 0x8da <battleground name>.24B (CZ_REQ_ENTRY_QUEUE_CANCEL)
void clif_parse_bg_queue_cancel_request(int fd, map_session_data *sd)
{
-	if (!battle_config.feature_bgqueue)
+	if (!battle_config.feature_bgqueue || !battle_config.bg_queue_interface)
		return;

	nullpo_retv(sd);
@ -18546,7 +18696,10 @@ void clif_parse_bg_queue_cancel_request(int fd, map_session_data *sd)

	char name[NAME_LENGTH];

-	safestrncpy( name, RFIFOCP( fd, 2 ), NAME_LENGTH );
+	if (battle_config.bg_rotation_mode)
+		safestrncpy( name, "Battleground Arena", NAME_LENGTH );
+	else
+		safestrncpy( name, RFIFOCP( fd, 2 ), NAME_LENGTH );

	clif_bg_queue_cancel_result(success, name, sd);
}
@ -18555,6 +18708,9 @@ void clif_parse_bg_queue_cancel_request(int fd, map_session_data *sd)
/// 0x8df <battleground name>.24B <lobby name>.24B (ZC_NOTIFY_LOBBY_ADMISSION)
void clif_bg_queue_lobby_notify(const char *name, map_session_data *sd)
{
+	if (!battle_config.bg_queue_interface)
+		return;
+
	nullpo_retv(sd);

	int fd = sd->fd;
@ -18589,6 +18745,9 @@ void clif_parse_bg_queue_lobby_reply(int fd, map_session_data *sd)
/// 0x8e1 <result>.B <battleground name>.24B <lobby name>.24B (ZC_REPLY_ACK_LOBBY_ADMISSION)
void clif_bg_queue_ack_lobby(bool result, const char *name, const char *lobbyname, map_session_data *sd)
{
+	if (!battle_config.bg_queue_interface)
+		return;
+
	nullpo_retv(sd);

	int fd = sd->fd;
@ -18605,11 +18764,17 @@ void clif_bg_queue_ack_lobby(bool result, const char *name, const char *lobbynam
/// 0x90a <battleground name>.24B (CZ_REQ_ENTRY_QUEUE_RANKING)
void clif_parse_bg_queue_request_queue_number(int fd, map_session_data *sd)
{
+	if (!battle_config.bg_queue_interface)
+		return;
+
	nullpo_retv(sd);

	char name[NAME_LENGTH];

-	safestrncpy( name, RFIFOCP(fd, 2), NAME_LENGTH );
+	if (battle_config.bg_rotation_mode)
+		safestrncpy( name, "Battleground Arena", NAME_LENGTH );
+	else
+		safestrncpy( name, RFIFOCP(fd, 2), NAME_LENGTH );

	clif_bg_queue_apply_notify(name, sd);
}
@ -18628,6 +18793,185 @@ void clif_bg_queue_entry_init(map_session_data *sd)
	clif_send( &p, sizeof( p ), &sd->bl, SELF );
}

+void clif_bg_memberlist(map_session_data *sd)
+{
+	map_session_data *psd;
+	int fd, c, i;
+	nullpo_retv(sd);
+
+#if PACKETVER < 20161026
+	int cmd = 0x154;
+	int size = 104;
+#else
+	int cmd = 0xaa5;
+	int size = 34;
+#endif
+
+	if((fd = sd->fd) == 0 )
+		return;
+	if(!sd->bg_id)
+		return;
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, sd->bg_id);
+	if (!bg)
+		return;
+
+	WFIFOHEAD(fd,bg->members.size() * 104 + 4);
+	WFIFOW(fd,0) = 0x154;
+	for( i = 0, c = 0; i < bg->members.size(); i++ )
+	{
+		if( (psd = bg->members[i].sd) == NULL )
+			continue;
+		WFIFOL(fd,c*104+ 4) = psd->status.account_id;
+		WFIFOL(fd,c*104+ 8) = psd->status.char_id;
+		WFIFOW(fd,c*104+12) = psd->status.hair;
+		WFIFOW(fd,c*104+14) = psd->status.hair_color;
+		WFIFOW(fd,c*104+16) = psd->status.sex;
+		WFIFOW(fd,c*104+18) = psd->status.class_;
+		WFIFOW(fd,c*104+20) = psd->status.base_level;
+		WFIFOL(fd,c*104+22) = 0; // Exp slot used to show kills
+		WFIFOL(fd,c*104+26) = 1; // Online
+		WFIFOL(fd,c*104+30) = psd->state.bmaster_flag ? 0 : 1; // Position
+		WFIFOL(fd,c*104+34)=(uint32)time(NULL);
+		memcpy(WFIFOP(fd,c*104+84),psd->status.name,NAME_LENGTH);
+		
+		c++;
+	}
+	WFIFOW(fd, 2)=c*104+4;
+	WFIFOSET(fd,WFIFOW(fd,2));
+}
+
+int clif_visual_guild_id(struct block_list *bl)
+{
+	int bg_id;
+	nullpo_ret(bl);
+	if ((bg_id = bg_team_get_id(bl)) == 0)
+		return status_get_guild_id(bl);
+
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_id);
+
+	if (bg && bg->g)
+		return bg->g->guild_id;
+
+	return 0;
+}
+
+int clif_visual_emblem_id(struct block_list *bl)
+{
+	int bg_id;
+	nullpo_ret(bl);
+	if ((bg_id = bg_team_get_id(bl)) == 0)
+		return status_get_emblem_id(bl);
+
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_id);
+
+	if (bg && bg->g)
+		return bg->g->emblem_id;
+
+	return 0;
+}
+
+/// Notifies the client that it is belonging to a guild (ZC_UPDATE_GDID).
+/// 016c <guild id>.L <emblem id>.L <mode>.L <ismaster>.B <inter sid>.L <guild name>.24B
+/// mode:
+///     &0x01 = allow invite
+///     &0x10 = allow expel
+void clif_bg_belonginfo(struct map_session_data *sd)
+{
+	struct guild *guild;
+
+	nullpo_retv(sd);
+
+	if ((guild = bg_guild_get(sd->bg_id)) == NULL)
+		return;
+
+	struct PACKET_ZC_UPDATE_GDID p = {};
+
+	p.PacketType = HEADER_ZC_UPDATE_GDID;
+	p.guildId = guild->guild_id;
+	p.emblemVersion = guild->emblem_id;
+	p.mode = 0;
+	p.isMaster = 0;
+	p.interSid = 0; // InterSID (unknown purpose)
+	safestrncpy( p.guildName, guild->name, sizeof( p.guildName ) );
+#if PACKETVER_MAIN_NUM >= 20220216
+	p.masterGID = guild->member[0].char_id;
+#endif
+
+	clif_send( &p, sizeof( p ), &sd->bl, SELF );
+}
+
+void clif_bg_emblem(struct map_session_data *sd, struct guild *g)
+{
+	int fd;
+
+	nullpo_retv(sd);
+	nullpo_retv(g);
+
+	if( g->emblem_len <= 0 )
+		return;
+
+	fd = sd->fd;
+	WFIFOHEAD(fd,g->emblem_len+12);
+	WFIFOW(fd,0)=0x152;
+	WFIFOW(fd,2)=g->emblem_len+12;
+	WFIFOL(fd,4)=g->guild_id;
+	WFIFOL(fd,8)=g->emblem_id;
+	memcpy(WFIFOP(fd,12),g->emblem_data,g->emblem_len);
+	WFIFOSET(fd,WFIFOW(fd,2));
+}
+
+void clif_bg_leave_single(struct map_session_data *sd, const char *name, const char *mes)
+{
+	int fd;
+	nullpo_retv(sd);
+
+	fd = sd->fd;
+	WFIFOHEAD(fd, 66);
+	WFIFOW(fd, 0) = 0x15a;
+	memcpy(WFIFOP(fd, 2), name, NAME_LENGTH);
+	memcpy(WFIFOP(fd, 26), mes, 40);
+	WFIFOSET(fd, 66);
+}
+
+void clif_bg_basicinfo(map_session_data& sd){
+	if (!sd.bg_id){
+		return;
+	}
+
+	struct guild *guild = bg_guild_get(sd.bg_id);
+	struct PACKET_ZC_GUILD_INFO p = {};
+
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, sd.bg_id);
+	if (!bg)
+		return;
+
+	p.PacketType = HEADER_ZC_GUILD_INFO;
+	p.GDID = guild->guild_id;
+	p.level = guild->guild_lv;
+	p.userNum = bg->members.size();
+	p.maxUserNum = guild->max_member;
+	p.userAverageLevel = guild->average_lv;
+	p.exp = (uint32)cap_value( guild->exp, 0, MAX_GUILD_EXP );
+	p.maxExp = (uint32)cap_value( guild->next_exp, 0, MAX_GUILD_EXP );
+	p.point = 0; // Tax Points
+	p.honor = 0; // Honor: (left) Vulgar [-100,100] Famed (right)
+	p.virtue = 0; // Virtue: (down) Wicked [-100,100] Righteous (up)
+	p.emblemVersion = guild->emblem_id;
+	safestrncpy( p.guildname, guild->name, sizeof( p.guildname ) );
+	safestrncpy( p.manageLand, msg_txt( &sd, 300), sizeof( p.manageLand ) );
+	p.zeny = 0;
+#if PACKETVER >= 20200902
+	p.masterGID = bg->leader_char_id; // leader
+	safestrncpy( p.masterName, guild->master, sizeof( p.masterName ) );
+#elif PACKETVER_MAIN_NUM >= 20161019 || PACKETVER_RE_NUM >= 20160921 || defined(PACKETVER_ZERO)
+	p.masterGID = bg->leader_char_id; // leader
+#else
+	safestrncpy( p.masterName, guild->master, sizeof( p.masterName ) );
+#endif
+
+	clif_send( &p, sizeof( p ), &sd.bl, SELF );
+}

/// Custom Fonts (ZC_NOTIFY_FONT).
/// 02ef <account_id>.L <font id>.W
void clif_font(map_session_data *sd)
@ -19691,6 +20035,43 @@ void clif_parse_SkillSelectMenu(int fd, map_session_data *sd) {
		sd->state.workinprogress = WIP_DISABLE_NONE;
		skill_autospell(sd, RFIFOW(fd, info->pos[1]));
	} else if (sd->menuskill_id == SC_AUTOSHADOWSPELL) {
+		// Check Equip Extended [Easycore]
+		if (sd->state.check_equip_skill) {
+			int skill = RFIFOW(fd, info->pos[1]);
+			struct map_session_data *tsd = map_id2sd(sd->state.check_equip_skill);
+
+			sd->state.check_equip_skill = 0;
+			sd->state.workinprogress = WIP_DISABLE_NONE;
+			clif_menuskill_clear(sd);
+
+			if (!tsd) {
+				clif_displaymessage(fd, msg_txt(sd,2005)); //Player not found.
+				return;
+			}
+
+			if (!(skill >= CS_EQUIPMENT && skill <= CS_WOE))
+				return;
+
+			switch(skill) {
+				case CS_EQUIPMENT:
+					if (sd->bl.m != tsd->bl.m)
+						return;
+					else if( tsd->status.show_equip || pc_has_permission(sd, PC_PERM_VIEW_EQUIPMENT) )
+						clif_viewequip_ack(sd, tsd);
+					else
+						clif_msg(sd, VIEW_EQUIP_FAIL);
+					break;
+				case CS_BG:
+					pc_battle_stats(sd,tsd,1);
+					break;
+				case CS_WOE:
+					pc_battle_stats(sd,tsd,2);
+					break;
+				default:
+					return;
+			}	
+			return;
+		}
		if (pc_istrading(sd)) {
			clif_skill_fail(sd, sd->ud.skill_id, USESKILL_FAIL_LEVEL, 0);
			clif_menuskill_clear(sd);
@ -25141,6 +25522,28 @@ void clif_parse_partybooking_reply( int fd, map_session_data* sd ){
#endif
}

+void clif_rank_info(map_session_data *sd, int points, int total, e_rank ranktype)
+{
+	char message[100];
+
+	switch(ranktype) {
+		case RANK_BG:
+			if( points < 0 )
+				sprintf(message, msg_txt(sd, 2006), points, total); // [Your Battleground Rank -%d = %d points]
+			else
+				sprintf(message, msg_txt(sd, 2007), points, total); // [Your Battleground Rank +%d = %d points]
+			break;
+		case RANK_WOE:
+			if( points < 0 )
+				sprintf(message, msg_txt(sd, 2008), points, total); // [Your War of Emperium Rank -%d = %d points]
+			else
+				sprintf(message, msg_txt(sd, 2009), points, total); // [Your War of Emperium Rank +%d = %d points]
+			break;
+	}
+	clif_displaymessage(sd->fd, message);
+}
+
+
/*==========================================
 * Main client packet processing function
 *------------------------------------------*/

	


+++ src\map\pc.cpp
@@ -93,6 +93,8 @@ int pc_expiration_tid = INVALID_TIMER;
struct fame_list smith_fame_list[MAX_FAME_LIST];
struct fame_list chemist_fame_list[MAX_FAME_LIST];
struct fame_list taekwon_fame_list[MAX_FAME_LIST];
+struct fame_list bg_fame_list[MAX_FAME_LIST];
+struct fame_list woe_fame_list[MAX_FAME_LIST];

const std::string AttendanceDatabase::getDefaultLocation(){
	return std::string(db_path) + "/attendance.yml";
@ -1009,6 +1011,333 @@ void pc_delabyssball( map_session_data& sd, int count ){
	clif_abyssball( sd );
}

+void pc_record_mobkills(map_session_data *sd, struct mob_data *md)
+{
+	nullpo_retv(sd);
+	int type = 0;
+	if (sd->guild && map_flag_gvg2(sd->bl.m) && is_agit_start()) {
+		switch(md->mob_id) {
+		case MOBID_EMPERIUM:
+			pc_addwoepoints(sd,100);
+			add2limit(sd->status.wstats.emperium_kill, 1, USHRT_MAX);
+			break;
+		case 1905:
+			pc_addwoepoints(sd,5);
+			add2limit(sd->status.wstats.barricade_kill, 1, USHRT_MAX);
+			break;
+		case MOBID_GUARDIAN_STONE1:
+		case MOBID_GUARDIAN_STONE2:
+			pc_addwoepoints(sd,10);
+			add2limit(sd->status.wstats.gstone_kill, 1, USHRT_MAX);
+			break;
+		case 1285:
+		case 1286:
+		case 1287:
+		case 1899:
+		case 1900:
+			pc_addwoepoints(sd,10);
+			add2limit(sd->status.wstats.guardian_kill, 1, USHRT_MAX);
+			break;
+		}
+	}
+	return;
+}
+
+void pc_record_damage(struct block_list *src, struct block_list *target, int damage)
+{
+	if (!src || !target || src == target || damage <= 0)
+		return;
+
+	struct block_list *s_bl;
+	struct map_session_data *sd;
+	struct mob_data *md;
+
+	if ((s_bl = battle_get_master(src)) == NULL)
+		s_bl = src;
+
+	if (s_bl->type != BL_PC)
+		return;
+
+	sd = BL_CAST(BL_PC, s_bl);
+
+	switch(target->type) {
+		case BL_PC:
+			if (sd->bg_id && map_getmapflag(src->m, MF_BATTLEGROUND)) {
+				add2limit(sd->status.bgstats.damage_done, damage, UINT_MAX);
+				add2limit(((TBL_PC*)target)->status.bgstats.damage_received, damage, UINT_MAX);
+				if (sd->status.bgstats.top_damage < damage)
+					sd->status.bgstats.top_damage = damage;
+			}
+			else if (map_flag_gvg2(src->m) && is_agit_start()) {
+				add2limit(sd->status.wstats.damage_done, damage, UINT_MAX);
+				add2limit(((TBL_PC*)target)->status.wstats.damage_received, damage, UINT_MAX);
+				if (sd->status.wstats.top_damage < damage)
+					sd->status.wstats.top_damage = damage;
+			}
+			break;
+		case BL_MOB: {
+			if ((md = BL_CAST(BL_MOB, target))== NULL)
+				return;
+			if (sd->bg_id && map_getmapflag(src->m, MF_BATTLEGROUND)) {
+				if (md->mob_id >= 21406 || md->mob_id <= 21408)
+				add2limit(sd->status.bgstats.boss_damage, damage, UINT_MAX);
+			} else if (map_flag_gvg2(src->m) && is_agit_start()) {
+				switch(md->mob_id) {
+					case MOBID_EMPERIUM:
+						add2limit(sd->status.wstats.emperium_damage, damage, UINT_MAX);
+						break;
+					case 1905:
+						add2limit(sd->status.wstats.barricade_damage, damage, UINT_MAX);
+						break;
+					case MOBID_GUARDIAN_STONE1:
+					case MOBID_GUARDIAN_STONE2:
+						add2limit(sd->status.wstats.gstone_damage, damage, UINT_MAX);
+						break;
+					default:
+						add2limit(sd->status.wstats.guardian_damage, damage, UINT_MAX);
+						break;
+				}
+			}
+			break;
+		}
+	}
+}
+
+void pc_rank_reset(int type)
+{
+	map_session_data *sd = NULL;
+	struct s_mapiterator* iter = NULL;
+	int i;
+
+	iter = mapit_getallusers();
+	for (sd = (TBL_PC*)mapit_first(iter); mapit_exists(iter); sd = (TBL_PC*)mapit_next(iter))	
+	{
+		switch(type) {
+			case RANK_BG: // Battleground Stats}
+				sd->status.bgstats.points = 0;
+				chrif_save(sd, CSAVE_NORMAL);
+				break;
+			case RANK_WOE: // WoE Ranking Reset
+				sd->status.wstats.points = 0;
+				chrif_save(sd, CSAVE_NORMAL);
+				break;
+		}
+	}
+	mapit_free(iter);
+
+	switch(type) {
+		case RANK_BG:
+			if( SQL_ERROR == Sql_Query(mmysql_handle, "UPDATE `char_bg` SET `points` = '0'") )
+				Sql_ShowDebug(mmysql_handle);
+			break;
+		case RANK_WOE:
+			if( SQL_ERROR == Sql_Query(mmysql_handle, "UPDATE `char_wstats` SET `points` = '0'") )
+				Sql_ShowDebug(mmysql_handle);
+			break;
+	}
+
+	chrif_buildfamelist();
+}
+
+void pc_battle_stats(map_session_data *sd, map_session_data *tsd, int flag)
+{
+	if (!sd || !tsd)
+		return;
+
+	char output[CHAT_SIZE_MAX];
+
+	// Battleground Stats
+	if (flag == 1) {
+		if (sd != tsd && tsd->status.bgstats.showstats) {
+			clif_displaymessage(sd->fd, "Player doesn not allow to show this information");
+			return;
+		}
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "============ BATTLEGROUND STATS ============", false, SELF);
+		sprintf(output, "    Name: %s (%s)", tsd->status.name,job_name(tsd->status.class_)); clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		if (pc_famerank(tsd->status.char_id,-1))
+			sprintf(output, "    Rank: %d    -    Points: %d", pc_famerank(tsd->status.char_id,-1),tsd->status.bgstats.points);
+		else
+			sprintf(output, "    Rank: N/A    -    Points: %d",tsd->status.bgstats.points);
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		sprintf(output, "    Wins: %d    -    Lost: %d    -    Draw: %d",tsd->status.bgstats.win,tsd->status.bgstats.lost,tsd->status.bgstats.tie);
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		sprintf(output, "    Kills: %d    -    Deaths: %d", tsd->status.bgstats.kill_count, tsd->status.bgstats.death_count);
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		sprintf(output, "    Damage dealt: %d    -    Top damage: %d", tsd->status.bgstats.damage_done,tsd->status.bgstats.top_damage);
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		sprintf(output, "    Damage received: %d    -    Healing done: %d", tsd->status.bgstats.damage_received, tsd->status.bgstats.healing_done);
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		sprintf(output, "    Deserter times: %d", tsd->status.bgstats.deserter);
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		sprintf(output, "    HP Potions: %d    -    SP Potions: %d", tsd->status.bgstats.hp_heal_potions, tsd->status.bgstats.sp_heal_potions);
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		sprintf(output, "    SP used: %d", tsd->status.bgstats.sp_used);
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		if (tsd->status.bgstats.yellow_gemstones || tsd->status.bgstats.red_gemstones|| tsd->status.bgstats.blue_gemstones) {
+			sprintf(output, "    Yellow G.: %d    -    Red G.: %d    -    Blue G.: %d", tsd->status.bgstats.yellow_gemstones, tsd->status.bgstats.red_gemstones, tsd->status.bgstats.blue_gemstones);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.poison_bottles) {
+			sprintf(output, "    Poison Bottles: %d", tsd->status.bgstats.poison_bottles);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.zeny_used || tsd->status.bgstats.spiritb_used || tsd->status.bgstats.ammo_used) {
+			sprintf(output, "    Zeny used: %d    -    Spirit Ball: %d    -    Ammo used: %d", tsd->status.bgstats.zeny_used, tsd->status.bgstats.spiritb_used, tsd->status.bgstats.ammo_used);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.leader_win || tsd->status.bgstats.leader_lost || tsd->status.bgstats.leader_tie) {
+			sprintf(output, "    Leader wins: %d    -    Leader lost: %d    -    Leader draw: %d", tsd->status.bgstats.leader_win, tsd->status.bgstats.leader_lost, tsd->status.bgstats.leader_tie);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.ti_wins || tsd->status.bgstats.ti_lost || tsd->status.bgstats.ti_tie) {
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "___________ Triple Inferno ___________", false, SELF);
+			sprintf(output, "    Wins: %d    -    Lost: %d    -    Draw: %d", tsd->status.bgstats.ti_wins, tsd->status.bgstats.ti_lost, tsd->status.bgstats.ti_tie);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Skulls (points): %d", tsd->status.bgstats.skulls);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.eos_wins || tsd->status.bgstats.eos_lost || tsd->status.bgstats.eos_tie) {
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "___________ Eye of the Storm ___________", false, SELF);
+			sprintf(output, "    Wins: %d    -    Lost: %d    -    Draw: %d", tsd->status.bgstats.eos_wins, tsd->status.bgstats.eos_lost, tsd->status.bgstats.eos_tie);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Flags: %d    -    Bases: %d", tsd->status.bgstats.eos_flags, tsd->status.bgstats.eos_bases);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.boss_wins || tsd->status.bgstats.boss_lost || tsd->status.bgstats.boss_tie) {
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "___________ Tierra Bossnia ___________", false, SELF);
+			sprintf(output, "    Wins: %d    -    Lost: %d    -    Draw: %d", tsd->status.bgstats.boss_wins, tsd->status.bgstats.boss_lost, tsd->status.bgstats.boss_tie);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Boss kills: %d    -    Boss damage: %d    -    Flags: %d", tsd->status.bgstats.boss_killed, tsd->status.bgstats.eos_bases, tsd->status.bgstats.boss_flags);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.td_wins || tsd->status.bgstats.td_lost || tsd->status.bgstats.td_tie) {
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "___________ Team Deathmatch ___________", false, SELF);
+			sprintf(output, "    Wins: %d    -    Lost: %d    -    Draw: %d", tsd->status.bgstats.td_wins, tsd->status.bgstats.td_lost, tsd->status.bgstats.td_tie);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Kills: %d    -    Deaths: %d", tsd->status.bgstats.td_kills, tsd->status.bgstats.td_deaths);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.dom_wins || tsd->status.bgstats.dom_lost || tsd->status.bgstats.dom_tie) {
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "___________ Domination ___________", false, SELF);
+			sprintf(output, "    Wins: %d    -    Lost: %d    -    Draw: %d", tsd->status.bgstats.dom_wins, tsd->status.bgstats.dom_lost, tsd->status.bgstats.dom_tie);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Offensive Kills: %d    -    Defensive Kills: %d", tsd->status.bgstats.dom_off_kills, tsd->status.bgstats.dom_def_kills);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Bases: %d", tsd->status.bgstats.dom_bases);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.sc_wins || tsd->status.bgstats.sc_lost || tsd->status.bgstats.sc_tie) {
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "___________ Stone Control ___________", false, SELF);
+			sprintf(output, "    Wins: %d    -    Lost: %d    -    Draw: %d", tsd->status.bgstats.sc_wins, tsd->status.bgstats.sc_lost, tsd->status.bgstats.sc_tie);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Captures: %d    -    Stone Stolen: %d-    Stone Dropped: %d", tsd->status.bgstats.sc_captured, tsd->status.bgstats.sc_stole, tsd->status.bgstats.sc_droped);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.ctf_wins || tsd->status.bgstats.ctf_lost || tsd->status.bgstats.ctf_tie) {
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "___________ Capture the Flag ___________", false, SELF);
+			sprintf(output, "    Wins: %d    -    Lost: %d    -    Draw: %d", tsd->status.bgstats.ctf_wins, tsd->status.bgstats.ctf_lost, tsd->status.bgstats.ctf_tie);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Flag captures: %d    -    Flag taken: %d    -    Flag Dropped: %d", tsd->status.bgstats.ctf_captured, tsd->status.bgstats.ctf_taken, tsd->status.bgstats.ctf_droped);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.cq_wins || tsd->status.bgstats.cq_lost) {
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "___________ Conquest ___________", false, SELF);
+			sprintf(output, "    Wins: %d    -    Lost: %d", tsd->status.bgstats.cq_wins, tsd->status.bgstats.cq_lost);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Emperium kills: %d    -    Barricade Kills: %d", tsd->status.bgstats.emperium_kill, tsd->status.bgstats.barricade_kill);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Guardian Stone kills: %d", tsd->status.bgstats.gstone_kill);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.ru_wins || tsd->status.bgstats.ru_lost) {
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "___________ Rush ___________", false, SELF);
+			sprintf(output, "    Wins: %d    -    Lost: %d", tsd->status.bgstats.ru_wins, tsd->status.bgstats.ru_lost);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Captures: %d", tsd->status.bgstats.ru_captures);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+	// War of Emperium Stats
+	} else {
+		if (sd != tsd && tsd->status.wstats.showstats) {
+			clif_displaymessage(sd->fd, "Player doesn not allow to show this information");
+			return;
+		}
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], "============ WAR OF EMPERIUM STATS ============", false, SELF);
+		sprintf(output, "    Name: %s (%s)", tsd->status.name,job_name(tsd->status.class_));
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		if (pc_famerank(tsd->status.char_id,-2))
+			sprintf(output, "    Rank: %d    -    Points: %d", pc_famerank(tsd->status.char_id,-2),tsd->status.bgstats.points);
+		else
+			sprintf(output, "    Rank: N/A    -    Points: %d",tsd->status.bgstats.points);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		sprintf(output, "    Wins: %d    -    Lost: %d    -    Draw: %d",tsd->status.bgstats.win,tsd->status.bgstats.lost,tsd->status.bgstats.tie);
+		sprintf(output, "    Kills: %d    -    Deaths: %d", tsd->status.wstats.kill_count, tsd->status.wstats.death_count);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		sprintf(output, "    Damage dealt: %d    -    Top damage: %d", tsd->status.wstats.damage_done,tsd->status.wstats.top_damage);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		sprintf(output, "    Damage received: %d    -    Healing done: %d", tsd->status.wstats.damage_received, tsd->status.wstats.healing_done);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		sprintf(output, "    HP Potions: %d    -    SP Potions: %d", tsd->status.wstats.hp_heal_potions, tsd->status.wstats.sp_heal_potions);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		sprintf(output, "    SP used: %d", tsd->status.wstats.sp_used);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		sprintf(output, "    Emperium kills: %d    -    Emperium damage: %d", tsd->status.wstats.emperium_kill, tsd->status.wstats.emperium_damage);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		sprintf(output, "    Barricade kills: %d    -    Barricade damage: %d", tsd->status.wstats.barricade_kill, tsd->status.wstats.barricade_damage);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		sprintf(output, "    Guardian kills: %d    -    Guardian damage: %d", tsd->status.wstats.guardian_kill, tsd->status.wstats.guardian_damage);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		if (tsd->status.wstats.yellow_gemstones || tsd->status.wstats.red_gemstones|| tsd->status.wstats.blue_gemstones) {
+			sprintf(output, "    Yellow G.: %d    -    Red G.: %d    -    Blue G.: %d", tsd->status.wstats.yellow_gemstones, tsd->status.wstats.red_gemstones, tsd->status.wstats.blue_gemstones);
+			clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		}
+		if (tsd->status.wstats.poison_bottles) {
+			sprintf(output, "    Poison Bottles: %d", tsd->status.wstats.poison_bottles);
+			clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		}
+		if (tsd->status.wstats.zeny_used || tsd->status.wstats.spiritb_used || tsd->status.wstats.ammo_used) {
+			sprintf(output, "    Zeny used: %d    -    Spirit Ball: %d    -    Ammo used: %d", tsd->status.wstats.zeny_used, tsd->status.wstats.spiritb_used, tsd->status.wstats.ammo_used);
+			clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		}
+	}
+}
+
+/**
+* Increases a player's battleground points and displays a notice to him
+* @param sd Player
+* @param count BG Point
+*/
+void pc_addbgpoints(map_session_data *sd,int count)
+{
+	nullpo_retv(sd);
+
+	clif_specialeffect(&sd->bl, EF_ENHANCE, SELF);
+	sd->status.bgstats.points += count;
+	if (sd->status.bgstats.points > MAX_FAME)
+		sd->status.bgstats.points = MAX_FAME;
+
+	clif_rank_info(sd,count,sd->status.bgstats.points,RANK_BG);
+	chrif_updatefamelist(*sd, RANK_BG);
+}
+
+/**
+* Increases a player's war of emperium points and displays a notice to him
+* @param sd Player
+* @param count WoE Point
+*/
+void pc_addwoepoints(map_session_data *sd,int count)
+{
+	nullpo_retv(sd);
+
+	clif_specialeffect(&sd->bl, EF_ENHANCE, SELF);
+	sd->status.wstats.points += count;
+	if (sd->status.wstats.points > MAX_FAME)
+		sd->status.wstats.points = MAX_FAME;
+
+	clif_rank_info(sd,count,sd->status.wstats.points,RANK_WOE);
+	chrif_updatefamelist(*sd, RANK_WOE);
+}
+
/**
* Increases a player's fame points and displays a notice to him
* @param sd Player
@ -1046,6 +1375,22 @@ bool pc_addfame(map_session_data &sd, int count)
unsigned char pc_famerank(uint32 char_id, int job)
{
	uint8 i;
+	// Battleground Rank [Easycore]
+	if (job == -1) {
+		for(i = 0; i < MAX_FAME_LIST; i++){
+			if(bg_fame_list[i].id == char_id)
+				return i + 1;
+		}
+		return 0;
+	}
+	// War of Emperium Rank [Easycore]
+	else if (job == -2) {
+		for(i = 0; i < MAX_FAME_LIST; i++){
+			if(woe_fame_list[i].id == char_id)
+				return i + 1;
+		}
+		return 0;
+	}

	switch(job){
		case MAPID_BLACKSMITH: // Blacksmith
@ -5749,9 +6094,18 @@ int pc_getcash(map_session_data *sd, int cash, int points, e_log_pick_type type)
 * @return Stored index in inventory, or -1 if not found.
 **/
short pc_search_inventory(map_session_data *sd, t_itemid nameid) {
-	short i;
+	short i,x,y;
	nullpo_retr(-1, sd);

+	if (map_getmapflag(sd->bl.m, MF_BG_CONSUME)) {
+		ARR_FIND( 0, MAX_INVENTORY, x, sd->inventory.u.items_inventory[x].nameid == nameid && ( MakeDWord(sd->inventory.u.items_inventory[x].card[2], sd->inventory.u.items_inventory[x].card[3]) == battle_config.bg_reserved_char_id ) && (sd->inventory.u.items_inventory[x].amount > 0 || nameid == 0) );
+			if( x < MAX_INVENTORY ) return x;
+	}
+	if (map_getmapflag(sd->bl.m, MF_WOE_CONSUME)) {
+		ARR_FIND( 0, MAX_INVENTORY, y, sd->inventory.u.items_inventory[y].nameid == nameid && ( MakeDWord(sd->inventory.u.items_inventory[y].card[2], sd->inventory.u.items_inventory[y].card[3]) == battle_config.woe_reserved_char_id ) && (sd->inventory.u.items_inventory[y].amount > 0 || nameid == 0) );
+			if( y < MAX_INVENTORY ) return y;
+	}
+
	ARR_FIND( 0, MAX_INVENTORY, i, sd->inventory.u.items_inventory[i].nameid == nameid && (sd->inventory.u.items_inventory[i].amount > 0 || nameid == 0) );
	return ( i < MAX_INVENTORY ) ? i : -1;
}
@ -6273,6 +6627,13 @@ int pc_useitem(map_session_data *sd,int n)
		return 0;
	}

+	if( sd->inventory.u.items_inventory[n].card[0] == CARD0_CREATE) {
+		if (MakeDWord(sd->inventory.u.items_inventory[n].card[2], sd->inventory.u.items_inventory[n].card[3]) == battle_config.bg_reserved_char_id && !map_getmapflag(sd->bl.m, MF_BG_CONSUME))
+			return 0;
+		if (MakeDWord(sd->inventory.u.items_inventory[n].card[2], sd->inventory.u.items_inventory[n].card[3]) == battle_config.woe_reserved_char_id && !map_getmapflag(sd->bl.m, MF_WOE_CONSUME))
+			return 0;
+	}

	sd->itemid = item.nameid;
	sd->itemindex = n;
	if(sd->catch_target_class != PET_CATCH_FAIL) //Abort pet catching.
@ -9689,6 +10050,24 @@ int pc_dead(map_session_data *sd,struct block_list *src)
			// To-do: Receive exp on certain occasions
#endif
		}
+		// Extended Battleground [Easycore]
+		if (sd && sd->bg_id) {
+			achievement_update_objective(sd, AG_BG_DIE, 1, 1);
+			add2limit(sd->status.bgstats.death_count, 1, USHRT_MAX);
+		}
+		if (ssd->bg_id && ssd->bg_id != sd->bg_id) {
+			achievement_update_objective(ssd, AG_BG_DAMAGE, 1, ssd->status.bgstats.damage_done);
+			achievement_update_objective(ssd, AG_BG_KILL, 1, 1);
+			add2limit(ssd->status.bgstats.kill_count, 1, USHRT_MAX);
+		}
+		
+		if (map_flag_gvg2(sd->bl.m) && is_agit_start()) {
+			achievement_update_objective(sd, AG_WOE_DAMAGE, 1, sd->status.wstats.damage_done);
+			achievement_update_objective(sd, AG_WOE_DIE, 1, 1);
+			achievement_update_objective(ssd, AG_WOE_KILL, 1, 1);
+			add2limit(sd->status.wstats.death_count, 1, USHRT_MAX);
+			add2limit(ssd->status.wstats.kill_count, 1, USHRT_MAX);
+		}
	}

	if(battle_config.bone_drop==2
@ -10431,6 +10810,9 @@ int pc_itemheal(map_session_data *sd, t_itemid itemid, int hp, int sp)
		tmp = hp * bonus / 100; // Overflow check
		if (bonus != 100 && tmp > hp)
			hp = tmp;
+		//Extended Features BG [Easycore]
+		if( map_getmapflag(sd->bl.m, MF_BATTLEGROUND) && sd->bg_id )
+			add2limit(sd->status.bgstats.hp_heal_potions, 1, UINT_MAX);
	}
	if (sp) {
		bonus = 100 + (sd->battle_status.int_ * 2) + pc_checkskill(sd, MG_SRECOVERY) * 10 + pc_checkskill(sd, AM_LEARNINGPOTION) * 5;
@ -10453,6 +10835,9 @@ int pc_itemheal(map_session_data *sd, t_itemid itemid, int hp, int sp)
		tmp = sp * bonus / 100; // Overflow check
		if (bonus != 100 && tmp > sp)
			sp = tmp;
+		//Extended Features BG [Easycore]
+		if( map_getmapflag(sd->bl.m, MF_BATTLEGROUND) && sd->bg_id )
+			add2limit(sd->status.bgstats.sp_heal_potions, 1, UINT_MAX);
	}
	if (sd->sc.count) {
		// Critical Wound and Death Hurt stack
@ -11060,6 +11445,12 @@ bool pc_candrop(map_session_data *sd, struct item *item)
		return false;
	if( !pc_can_give_items(sd) || sd->sc.cant.drop) //check if this GM level can drop items
		return false;
+	if( item->card[0] == CARD0_CREATE) {
+		if (MakeDWord(item->card[2], item->card[3]) == battle_config.bg_reserved_char_id)
+			return false;
+		if (MakeDWord(item->card[2], item->card[3]) == battle_config.woe_reserved_char_id)
+			return false;
+	}
	return (itemdb_isdropable(item, pc_get_group_level(sd)));
}

@ -15698,6 +16089,27 @@ uint64 CaptchaDatabase::parseBodyNode(const ryml::NodeRef &node) {
	return 1;
}

+/***********************************************************
+* Update Idle PC Timer
+***********************************************************/
+int pc_update_last_action(map_session_data *sd)
+{
+	if (!sd->bg_id)
+		return 1;
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, sd->bg_id);
+	sd->idletime = last_tick;
+
+	if (bg && sd->state.bg_afk)
+	{ // Battleground AFK announce
+		char output[128];
+		sprintf(output, msg_txt(NULL, 2010), bg->g->name, sd->status.name); // %s : %s is no longer AFK...
+		clif_bg_message(bg.get(), 0, bg->g->name, output, strlen(output) + 1);
+		sd->state.bg_afk = 0;
+	}
+
+	return 1;
+}
+
/*==========================================
 * pc Init/Terminate
 *------------------------------------------*/




	
+++ src\map\skill.cpp
@@ -855,6 +855,24 @@ bool skill_isNotOk(uint16 skill_id, map_session_data *sd)
		return true;
	}

+	// Extended Battleground [Easycore]
+	if (SKILL_CHK_GUILD(skill_id)) {
+		if (sd->bg_id) {
+			std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, sd->bg_id);
+			if (bg && bg_block_skill_status(bg.get(), skill_id))
+				return true;
+			else
+				return false;
+		} else {
+			if (skill_blockpc_get(sd, skill_id) != -1) {
+				char output[CHAT_SIZE_MAX];
+				snprintf(output, sizeof(output), msg_txt(sd, 2040), skill_get_desc(skill_id), guild_skills_timer(sd,skill_id)); // [%s] ready in %ds
+				clif_messagecolor(&sd->bl, color_table[COLOR_RED], output, false, GUILD);
+				return true;
+			}
+		}
+	}
+
	if (skill_blockpc_get(sd, skill_id) != -1){
		clif_skill_fail(sd,skill_id,USESKILL_FAIL_SKILLINTERVAL,0);
		return true;
@ -968,10 +986,14 @@ bool skill_isNotOk(uint16 skill_id, map_session_data *sd)
			break;
		case GD_EMERGENCYCALL:
		case GD_ITEMEMERGENCYCALL:
+			if (map_getmapflag(sd->bl.m, MF_NOECALL)) {
+				clif_displaymessage(sd->fd, msg_txt(sd,2011)); // Cannot use Emergency Call in this map.
+				return true;
+			}
			if (
-				!(battle_config.emergency_call&((is_agit_start())?2:1)) ||
+				!map_getmapflag(sd->bl.m, MF_BATTLEGROUND) && (!(battle_config.emergency_call&((is_agit_start())?2:1)) ||
				!(battle_config.emergency_call&(mapdata_flag_gvg2(mapdata)?8:4)) ||
-				(battle_config.emergency_call&16 && mapdata->flag[MF_NOWARPTO] && !(mapdata->flag[MF_GVG_CASTLE] || mapdata->flag[MF_GVG_TE_CASTLE]))
+				(battle_config.emergency_call&16 && map_getmapflag(sd->bl.m, MF_NOWARPTO) && !(map_getmapflag(sd->bl.m, MF_GVG_CASTLE) || map_getmapflag(sd->bl.m, MF_GVG_TE_CASTLE))))
			)	{
				clif_skill_fail(sd,skill_id,USESKILL_FAIL_LEVEL,0);
				return true;
@ -7233,6 +7255,23 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
			if( tsc && tsc->getSCE(SC_AKAITSUKI) && heal && skill_id != HLIF_HEAL )
				heal = ~heal + 1;
			t_exp heal_get_jobexp = status_heal(bl,heal,0,0);
+			// Extended Features BG [Easycore]
+			if (sd && dstsd) {
+				if (map_getmapflag(src->m, MF_BATTLEGROUND) && sd->bg_id && dstsd->bg_id) {
+					if (sd->bg_id == dstsd->bg_id) {
+						achievement_update_objective(sd, AG_BG_HEAL, 1, heal_get_jobexp);
+						add2limit(sd->status.bgstats.healing_done, heal_get_jobexp, UINT_MAX);
+					} else
+						add2limit(sd->status.bgstats.wrong_healing_done, heal_get_jobexp, UINT_MAX);
+				}
+				else if (is_agit_start() && map_flag_gvg2(src->m) && sd->guild && dstsd->guild) {
+					if (sd->guild == dstsd->guild) {
+						achievement_update_objective(sd, AG_WOE_HEAL, 1, heal_get_jobexp);
+						add2limit(sd->status.wstats.healing_done, heal_get_jobexp, UINT_MAX);
+					} else
+						add2limit(sd->status.wstats.wrong_healing_done, heal_get_jobexp, UINT_MAX);
+				}
+			}

			if(sd && dstsd && heal > 0 && sd != dstsd && battle_config.heal_exp > 0){
				heal_get_jobexp = heal_get_jobexp * battle_config.heal_exp / 100;
@ -7961,6 +8000,8 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui

	case CD_COMPETENTIA:
		if (sd == nullptr || sd->status.party_id == 0 || (flag & 1)) {
+			if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+				break;
			int hp_amount = tstatus->max_hp * (20 * skill_lv) / 100;
			int sp_amount = tstatus->max_sp * (20 * skill_lv) / 100;

@ -7971,8 +8012,11 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
			status_heal(bl, 0, sp_amount, 0);

			clif_skill_nodamage(bl, bl, skill_id, skill_lv, sc_start(src, bl, type, 100, skill_lv, skill_get_time(skill_id, skill_lv)));
-		} else if (sd)
-			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+		}
+		else if (sd && sd->bg_id)
+				map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
+			else if (sd)
+				party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag | BCT_PARTY | 1, skill_castend_nodamage_id);
		break;

	case BO_ADVANCE_PROTECTION:
@ -8237,6 +8281,8 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
			int8 count = min(5 + skill_lv, MAX_UNITED_SOULS);

			if (sd == nullptr || sd->status.party_id == 0 || (flag & 1)) {
+				if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+					break;
				if (!dstsd || !sd) { // Only put player's souls in unity.
					if (sd)
						clif_skill_fail(sd, skill_id, USESKILL_FAIL, 0);
@ -8265,10 +8311,12 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui

					sd->united_soul[i] = bl->id;
				}
-
				clif_skill_nodamage(src, bl, skill_id, skill_lv, sc_start4(src, bl, type, 100, skill_lv, src->id, i, 0, skill_get_time(skill_id, skill_lv)));
-			} else if (sd)
-				party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+			}
+			else if (sd && sd->bg_id)
+				map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
+			else if (sd)
+				party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag | BCT_PARTY | 1, skill_castend_nodamage_id);
		}
		break;

@ -8672,13 +8720,16 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
	case PR_MAGNIFICAT:
	case PR_GLORIA:
		if (sd == NULL || sd->status.party_id == 0 || (flag & 1)) {
-
+			if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+				break;
			// Animations don't play when outside visible range
			if (check_distance_bl(src, bl, AREA_SIZE))
				clif_skill_nodamage(bl, bl, skill_id, skill_lv, 1);

			sc_start(src, bl, type, 100, skill_lv, skill_get_time(skill_id, skill_lv));
		}
+		else if (sd && sd->bg_id)
+			map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
		else if (sd)
			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag | BCT_PARTY | 1, skill_castend_nodamage_id);
		break;
@ -8693,10 +8744,15 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
	case NV_HELPANGEL:
	case IG_GUARDIAN_SHIELD:
	case IG_ULTIMATE_SACRIFICE:// Is the animation on this skill correct? Check if its on caster only or all affected. [Rytech]
-		if( sd == NULL || sd->status.party_id == 0 || (flag & 1) )
+		if( sd == NULL || sd->status.party_id == 0 || (flag & 1) ) {
+			if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+				break;
			clif_skill_nodamage(bl, bl, skill_id, skill_lv, sc_start(src,bl,type,100,skill_lv,skill_get_time(skill_id,skill_lv)));
-		else if (sd)
-		{
+		}
+		else if (sd && sd->bg_id)
+			map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
+		else if (sd) {
+			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag | BCT_PARTY | 1, skill_castend_nodamage_id);
			if (skill_id == IG_ULTIMATE_SACRIFICE)
				status_set_hp(src, 1, 0);
			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
@ -8720,15 +8776,16 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
	case BS_OVERTHRUST:
		if (sd == NULL || sd->status.party_id == 0 || (flag & 1)) {
			int weapontype = skill_get_weapontype(skill_id);
+			if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+				break;
			if (!weapontype || !dstsd || pc_check_weapontype(dstsd, weapontype)) {
				clif_skill_nodamage(bl, bl, skill_id, skill_lv,
					sc_start2(src, bl, type, 100, skill_lv, (src == bl) ? 1 : 0, skill_get_time(skill_id, skill_lv)));
			}
-		} else if (sd) {
-			party_foreachsamemap(skill_area_sub,
-				sd,skill_get_splash(skill_id, skill_lv),
-				src,skill_id,skill_lv,tick, flag|BCT_PARTY|1,
-				skill_castend_nodamage_id);
+		else if (sd && sd->bg_id)
+			map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
+		else if (sd)
+			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag | BCT_PARTY | 1, skill_castend_nodamage_id);
		}
		break;

@ -10128,6 +10185,8 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
		// Updated to block Slim Pitcher from working on barricades and guardian stones.
		if (dstmd && (dstmd->mob_id == MOBID_EMPERIUM || status_get_class_(bl) == CLASS_BATTLEFIELD))
			break;
+		if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+			break;
		if (potion_hp || potion_sp) {
			int hp = potion_hp, sp = potion_sp;
			hp = hp * (100 + (tstatus->vit * 2))/100;
@ -10313,24 +10372,32 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
	case GD_RESTORE:
	case GD_EMERGENCY_MOVE:
		if(flag&1) {
-			if (status_get_guild_id(src) == status_get_guild_id(bl)) {				
+			if (status_get_guild_id(src) == status_get_guild_id(bl) || (map_getmapflag(src->m, MF_BATTLEGROUND) && bg_team_get_id(src) == bg_team_get_id(bl))) {		
				if( skill_id == GD_RESTORE )
					clif_skill_nodamage(src,bl,AL_HEAL,status_percent_heal(bl,90,90),1);
				else
					sc_start(src,bl,type,100,skill_lv,skill_get_time(skill_id, skill_lv));
			}
-		} else if (status_get_guild_id(src)) {
+		} else if (status_get_guild_id(src) || (map_getmapflag(src->m, MF_BATTLEGROUND) && bg_team_get_id(src))) {
			clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
			map_foreachinallrange(skill_area_sub, src,
				skill_get_splash(skill_id, skill_lv), BL_PC,
-				src,skill_id,skill_lv,tick, flag|BCT_GUILD|1,
+				src,skill_id,skill_lv,tick, flag|BCT_NOENEMY|1,
				skill_castend_nodamage_id);
-			if (sd)
+			if (sd) {
+				std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, sd->bg_id);
#ifdef RENEWAL
-				skill_blockpc_start(sd, skill_id, skill_get_cooldown(skill_id, skill_lv));
+				if (bg && sd->bg_id)
+					bg_block_skill_start(bg.get(), skill_id, skill_get_cooldown(skill_id, skill_lv));
+				else
+					skill_blockpc_start(sd, skill_id, skill_get_cooldown(skill_id, skill_lv));
#else
-				guild_block_skill(sd, skill_get_time2(skill_id, skill_lv));
+				if (bg && sd->bg_id)
+					bg_block_skill_start(bg.get(), skill_id, skill_get_time2(skill_id, skill_lv));
+				else
+					guild_block_skill(sd,skill_get_time2(skill_id,skill_lv));
#endif
+			}
		}
		break;
	case GD_EMERGENCYCALL:
@ -10339,10 +10406,17 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
			int8 dx[9] = {-1, 1, 0, 0,-1, 1,-1, 1, 0};
			int8 dy[9] = { 0, 0, 1,-1, 1,-1,-1, 1, 0};
			uint8 j = 0, calls = 0, called = 0;
-			struct guild *g;
-			// i don't know if it actually summons in a circle, but oh well. ;P
-			g = sd?sd->guild:guild_search(status_get_guild_id(src));
-			if (!g)
+			struct guild *g = NULL;
+			std::shared_ptr<s_battleground_data> bg = nullptr;
+			int max_member;
+			if (map_getmapflag(src->m, MF_BATTLEGROUND) && bg_team_get_id(src)) {
+				bg = util::umap_find(bg_team_db, bg_team_get_id(src));
+				max_member = bg->members.size();
+			} else {
+				g = sd?sd->guild:guild_search(status_get_guild_id(src));
+				max_member = g->max_member;
+			}
+			if (!g && !bg)
				break;

			if (skill_id == GD_ITEMEMERGENCYCALL)
@ -10354,11 +10428,11 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
				}

			clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
-			for (i = 0; i < g->max_member && (!calls || (calls && called < calls)); i++, j++) {
+			for (i = 0; i < max_member && (!calls || (calls && called < calls)); i++, j++) {
				if (j > 8)
					j = 0;
-				if ((dstsd = g->member[i].sd) != NULL && sd != dstsd && !dstsd->state.autotrade && !pc_isdead(dstsd)) {
-					if (map_getmapflag(dstsd->bl.m, MF_NOWARP) && !map_flag_gvg2(dstsd->bl.m))
+				if ((dstsd = bg?bg->members[i].sd:g->member[i].sd) != NULL && sd != dstsd && !dstsd->state.autotrade && !pc_isdead(dstsd)) {
+					if (map_getmapflag(dstsd->bl.m, MF_NOWARP) && !map_flag_gvg2(dstsd->bl.m) && !bg)
						continue;
					if (!pc_job_can_entermap((enum e_job)dstsd->status.class_, src->m, pc_get_group_level(dstsd)))
						continue;
@ -10368,12 +10442,19 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
						called++;
				}
			}
-			if (sd)
+			if (sd) {
#ifdef RENEWAL
-				skill_blockpc_start(sd, skill_id, skill_get_cooldown(skill_id, skill_lv));
+				if (sd->bg_id)
+					bg_block_skill_start(bg.get(), skill_id, skill_get_cooldown(skill_id, skill_lv));
+				else
+					skill_blockpc_start(sd, skill_id, skill_get_cooldown(skill_id, skill_lv));
#else
-				guild_block_skill(sd, skill_get_time2(skill_id, skill_lv));
+				if (sd->bg_id)
+					bg_block_skill_start(bg.get(), skill_id, skill_get_time2(skill_id, skill_lv));
+				else
+					guild_block_skill(sd,skill_get_time2(skill_id,skill_lv));
#endif
+			}
		}
		break;
	case GD_CHARGESHOUT_FLAG:
@ -10804,29 +10885,41 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
		{
			int bless_lv = ((sd) ? pc_checkskill(sd,AL_BLESSING) : skill_get_max(AL_BLESSING)) + (((sd) ? sd->status.job_level : 50) / 10);
			int agi_lv = ((sd) ? pc_checkskill(sd,AL_INCAGI) : skill_get_max(AL_INCAGI)) + (((sd) ? sd->status.job_level : 50) / 10);
-			if( sd == NULL || sd->status.party_id == 0 || flag&1 )
+			if( sd == NULL || sd->status.party_id == 0 || flag&1 ) {
+				if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+					break;
				clif_skill_nodamage(bl, bl, skill_id, skill_lv, sc_start(src,bl,type,100,
					(skill_id == AB_CLEMENTIA)? bless_lv : (skill_id == AB_CANTO)? agi_lv : skill_lv, skill_get_time(skill_id,skill_lv)));
-			else if( sd )
-				party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+			}
+			else if (sd && sd->bg_id)
+				map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
+			else if (sd)
+				party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag | BCT_PARTY | 1, skill_castend_nodamage_id);
		}
		break;

	case AB_PRAEFATIO:
	case AB_RENOVATIO:
		if( !sd || sd->status.party_id == 0 || flag&1 ) {
+			if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+				break;
			if (skill_id == AB_PRAEFATIO)
				clif_skill_nodamage(bl, bl, skill_id, skill_lv, sc_start4(src, bl, type, 100, skill_lv, 0, 0, (sd && sd->status.party_id ? party_foreachsamemap(party_sub_count, sd, 0) : 1 ), skill_get_time(skill_id, skill_lv)));
			else
				clif_skill_nodamage(bl, bl, skill_id, skill_lv, sc_start(src, bl, type, 100, skill_lv, skill_get_time(skill_id, skill_lv)));
-		} else if( sd )
-			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+		}
+		else if (sd && sd->bg_id)
+			map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
+		else if (sd)
+			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag | BCT_PARTY | 1, skill_castend_nodamage_id);
		break;

	case AB_CHEAL:
		if( !sd || sd->status.party_id == 0 || flag&1 ) {
			if( sd && tstatus && !battle_check_undead(tstatus->race, tstatus->def_ele) && !tsc->getSCE(SC_BERSERK) ) {
				int partycount = (sd->status.party_id ? party_foreachsamemap(party_sub_count, sd, 0) : 0);
+				if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+					break;

				i = skill_calc_heal(src, bl, AL_HEAL, pc_checkskill(sd, AL_HEAL), true);

@ -10840,8 +10933,11 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
					i = ~i + 1;
				status_heal(bl, i, 0, 0);
			}
-		} else if( sd )
-			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+		}
+		else if (sd && sd->bg_id)
+			map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
+		else if (sd)
+			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag | BCT_PARTY | 1, skill_castend_nodamage_id);
		break;

	case NPC_CHEAL:
@ -10875,6 +10971,8 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui

	case AB_LAUDAAGNUS:
		if( flag&1 || !sd || !sd->status.party_id ) {
+			if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+				break;
			if( tsc && (tsc->getSCE(SC_FREEZE) || tsc->getSCE(SC_STONE) || tsc->getSCE(SC_BLIND) ||
				tsc->getSCE(SC_BURNING) || tsc->getSCE(SC_FREEZING) || tsc->getSCE(SC_CRYSTALIZE))) {
				// Success Chance: (60 + 10 * Skill Level) %
@ -10888,13 +10986,17 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
			} else //Success rate only applies to the curing effect and not stat bonus. Bonus status only applies to non infected targets
				clif_skill_nodamage(bl, bl, skill_id, skill_lv,
					sc_start(src,bl, type, 100, skill_lv, skill_get_time(skill_id, skill_lv)));
-		} else if( sd )
-			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv),
-				src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+		}
+		else if (sd && sd->bg_id)
+			map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
+		else if (sd)
+			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag | BCT_PARTY | 1, skill_castend_nodamage_id);
		break;

	case AB_LAUDARAMUS:
		if( flag&1 || !sd || !sd->status.party_id ) {
+			if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+				break;
			if( tsc && (tsc->getSCE(SC_SLEEP) || tsc->getSCE(SC_STUN) || tsc->getSCE(SC_MANDRAGORA) || tsc->getSCE(SC_SILENCE) || tsc->getSCE(SC_DEEPSLEEP)) ){
				// Success Chance: (60 + 10 * Skill Level) %
				if( rnd()%100 > 60+10*skill_lv )  break;
@ -10906,9 +11008,11 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
			} else // Success rate only applies to the curing effect and not stat bonus. Bonus status only applies to non infected targets
				clif_skill_nodamage(bl, bl, skill_id, skill_lv,
					sc_start(src,bl, type, 100, skill_lv, skill_get_time(skill_id, skill_lv)));
-		} else if( sd )
-			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv),
-				src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+		}
+		else if (sd && sd->bg_id)
+			map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
+		else if (sd)
+			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag | BCT_PARTY | 1, skill_castend_nodamage_id);
		break;

	case AB_CLEARANCE:
@ -11489,10 +11593,17 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
	case MI_RUSH_WINDMILL:
	case MI_ECHOSONG:
		if( !sd || !sd->status.party_id || (flag & 1) ) {
+			if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+				break;
			clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
			sc_start2(src,bl,type,100,skill_lv,((sd) ? pc_checkskill(sd,WM_LESSON) : skill_get_max(WM_LESSON)),skill_get_time(skill_id,skill_lv));
-		} else if( sd ) {
-			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+		}
+		else if (sd && sd->bg_id) {
+			map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
+			sc_start2(src,bl,type,100,skill_lv,((sd) ? pc_checkskill(sd,WM_LESSON) : skill_get_max(WM_LESSON)),skill_get_time(skill_id,skill_lv));
+			clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
+		} else if (sd) {
+			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag | BCT_PARTY | 1, skill_castend_nodamage_id);
			sc_start2(src,bl,type,100,skill_lv,((sd) ? pc_checkskill(sd,WM_LESSON) : skill_get_max(WM_LESSON)),skill_get_time(skill_id,skill_lv));
			clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
		}
@ -11563,10 +11674,17 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
	case WM_UNLIMITED_HUMMING_VOICE:
		if( flag&1 ) {	// These affect to to all party members near the caster.
			status_change *sc = status_get_sc(src);
+			if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+				break;
			if( sc && sc->getSCE(type) ) {
				sc_start2(src,bl,type,100,skill_lv,pc_checkskill(sd, WM_LESSON),skill_get_time(skill_id,skill_lv));
			}
-		} else if( sd ) {
+		}
+		else if (sd && sd->bg_id) {
+			if( sc_start2(src,bl,type,100,skill_lv,pc_checkskill(sd, WM_LESSON),skill_get_time(skill_id,skill_lv)) )
+				party_foreachsamemap(skill_area_sub,sd,skill_get_splash(skill_id,skill_lv),src,skill_id,skill_lv,tick,flag|BCT_PARTY|1,skill_castend_nodamage_id);
+			clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
+		} else if (sd) {
			if( sc_start2(src,bl,type,100,skill_lv,pc_checkskill(sd, WM_LESSON),skill_get_time(skill_id,skill_lv)) )
				party_foreachsamemap(skill_area_sub,sd,skill_get_splash(skill_id,skill_lv),src,skill_id,skill_lv,tick,flag|BCT_PARTY|1,skill_castend_nodamage_id);
			clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
@ -12372,24 +12490,33 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
	case SU_MEOWMEOW:
		if (sd == NULL || sd->status.party_id == 0 || flag&1) {
			int duration = skill_get_time(skill_id, skill_lv);
+			if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+				break;

			if (skill_id == SU_BUNCHOFSHRIMP && pc_checkskill(sd, SU_SPIRITOFSEA))
				duration += skill_get_time2(SU_BUNCHOFSHRIMP, skill_lv);
			clif_skill_nodamage(bl, bl, skill_id, skill_lv, sc_start(src, bl, type, 100, skill_lv, duration));
-		} else if (sd) {
-			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
		}
+		else if (sd && sd->bg_id)
+			map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
+		else if (sd)
+			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag | BCT_PARTY | 1, skill_castend_nodamage_id);
		break;

	case SU_SHRIMPARTY:
		if (sd == NULL || sd->status.party_id == 0 || flag&1) {
+			if (flag&2 && sd && dstsd && sd->bg_id && sd->bg_id != dstsd->bg_id)
+				break;
			sc_start(src, bl, type, 100, skill_lv, skill_get_time(skill_id, skill_lv));
			if (sd && (i = pc_checkskill(sd, SU_FRESHSHRIMP)) > 0) {
				clif_skill_nodamage(bl, bl, SU_FRESHSHRIMP, i, 1);
				sc_start(src, bl, SC_FRESHSHRIMP, 100, i, skill_get_time(SU_FRESHSHRIMP, i));
			}
-		} else if (sd)
-			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+		}
+		else if (sd && sd->bg_id)
+			map_foreachinallrange(skill_area_sub,src,skill_get_splash(skill_id,skill_lv),BL_PC,src,skill_id,skill_lv,tick,flag|BCT_NOENEMY|1|2,skill_castend_nodamage_id);
+		else if (sd)
+			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag | BCT_PARTY | 1, skill_castend_nodamage_id);
		break;

	case SU_POWEROFFLOCK:
@ -17347,14 +17474,17 @@ bool skill_check_condition_castbegin(map_session_data* sd, uint16 skill_id, uint
		case GD_CHARGESHOUT_FLAG:
		case GD_CHARGESHOUT_BEATING:
		case GD_EMERGENCY_MOVE:
-			if (!map_flag_gvg2(sd->bl.m)) {
+			if (!map_flag_gvg2(sd->bl.m) && !map_getmapflag(sd->bl.m, MF_BATTLEGROUND)) {
				clif_skill_fail(sd,skill_id,USESKILL_FAIL_LEVEL,0);
				return false;
			}
		case GD_EMERGENCYCALL:
		case GD_ITEMEMERGENCYCALL:
			// other checks were already done in skill_isNotOk()
-			if (!sd->status.guild_id || (sd->state.gmaster_flag == 0 && skill_id != GD_CHARGESHOUT_BEATING))
+			if (map_getmapflag(sd->bl.m, MF_BATTLEGROUND)) {
+				if (sd->bg_id && !sd->state.bmaster_flag)
+					return false;
+			} else if (!sd->status.guild_id || (sd->state.gmaster_flag == 0 && skill_id != GD_CHARGESHOUT_BEATING))
				return false;
			break;

@ -18179,7 +18309,13 @@ bool skill_check_condition_castend(map_session_data* sd, uint16 skill_id, uint16
		if( !require.itemid[i] )
			continue;
		index[i] = pc_search_inventory(sd,require.itemid[i]);
-		if( index[i] < 0 || sd->inventory.u.items_inventory[index[i]].amount < require.amount[i] ) {
+		if( index[i] < 0 || sd->inventory.u.items_inventory[index[i]].amount < require.amount[i] ||
+			sd->inventory.u.items_inventory[index[i]].card[0] == CARD0_CREATE && 
+			((MakeDWord(sd->inventory.u.items_inventory[index[i]].card[2], sd->inventory.u.items_inventory[index[i]].card[3]) == 
+			battle_config.bg_reserved_char_id && !map_getmapflag(sd->bl.m, MF_BG_CONSUME)) ||
+			(MakeDWord(sd->inventory.u.items_inventory[index[i]].card[2], sd->inventory.u.items_inventory[index[i]].card[3]) == 
+			battle_config.woe_reserved_char_id && !map_getmapflag(sd->bl.m, MF_WOE_CONSUME)))
+		) {
			if( require.itemid[i] == ITEMID_HOLY_WATER )
				clif_skill_fail(sd,skill_id,USESKILL_FAIL_HOLYWATER,0); //Holy water is required.
			else if( require.itemid[i] == ITEMID_RED_GEMSTONE )
@ -18194,6 +18330,15 @@ bool skill_check_condition_castend(map_session_data* sd, uint16 skill_id, uint16
				clif_skill_fail( sd, skill_id, USESKILL_FAIL_NEED_ITEM, require.amount[i], require.itemid[i] ); // [%s] required '%d' amount.
			return false;
		}
+		if (sd->inventory.u.items_inventory[index[i]].card[0] == CARD0_CREATE && 
+			((MakeDWord(sd->inventory.u.items_inventory[index[i]].card[2], sd->inventory.u.items_inventory[index[i]].card[3]) == 
+			battle_config.bg_reserved_char_id && !map_getmapflag(sd->bl.m, MF_BG_CONSUME)) ||
+			(MakeDWord(sd->inventory.u.items_inventory[index[i]].card[2], sd->inventory.u.items_inventory[index[i]].card[3]) == 
+			battle_config.woe_reserved_char_id && !map_getmapflag(sd->bl.m, MF_WOE_CONSUME)))) {
+				clif_skill_fail( sd, skill_id, USESKILL_FAIL_NEED_ITEM, require.amount[i], require.itemid[i] ); // [%s] required '%d' amount.
+				clif_messagecolor(&sd->bl, color_table[COLOR_WHITE], "No puedes utilizar un item de BG/WoE en este mapa.", false, SELF);
+				return false;
+			}
	}

	/* check the status required */
@ -19503,6 +19648,9 @@ int skill_frostjoke_scream(struct block_list *bl, va_list ap)
		if ( sd && sd->sc.option&(OPTION_INVISIBLE|OPTION_MADOGEAR) )
			return 0;//Frost Joke / Scream cannot target invisible or MADO Gear characters [Ind]
	}
+	// Extended Battleground [Easycore]
+	if (map_getmapflag(bl->m, MF_BATTLEGROUND) && map_getcell(bl->m, bl->x, bl->y, CELL_CHKBASILICA))
+		return 0;
	//It has been reported that Scream/Joke works the same regardless of woe-setting. [Skotlex]
	if(battle_check_target(src,bl,BCT_ENEMY) > 0)
		skill_additional_effect(src,bl,skill_id,skill_lv,BF_MISC,ATK_DEF,tick);
		
		